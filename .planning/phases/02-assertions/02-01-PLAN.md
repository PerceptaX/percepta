---
phase: 02-assertions
plan: 01
type: execute
---

<objective>
Implement DSL parser and assertion evaluation logic for hardware validation.

Purpose: Enable deterministic validation of observed hardware state. Users write assertions like `LED.power ON` or `Display.status "Ready"` and percepta validates against observations.

Output: Working assertion types (LED, Display, Timing) with parser and evaluation engine.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-vision/01-03-SUMMARY.md

**Tech stack available:**
- Go 1.25
- Core types: Signal, Observation, LEDSignal, DisplaySignal, BootTimingSignal
- In-memory storage with Query() and Count() methods
- Parser patterns established (internal/vision/parser.go)

**Key files from Phase 1:**
@internal/core/types.go
@internal/storage/memory.go
@pkg/percepta/percepta.go

**Constraining decisions:**
- Deterministic evaluation (no probabilistic assertions in MVP)
- Human-readable DSL (not JSON or YAML)
- Simple parser (regex-based like SignalParser, not full grammar)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define assertion types and DSL structures</name>
  <files>internal/assertions/types.go</files>
  <action>
Create assertion types for LED, Display, and Timing validation:

```go
package assertions

import "github.com/perceptumx/percepta/internal/core"

// AssertionResult represents the outcome of an assertion evaluation
type AssertionResult struct {
	Passed      bool
	Expected    string
	Actual      string
	Confidence  float64
	Message     string
}

// Assertion interface - evaluates observed state
type Assertion interface {
	Evaluate(obs *core.Observation) AssertionResult
	String() string
}

// LEDAssertion validates LED state
type LEDAssertion struct {
	Name     string
	Expected LEDState
}

type LEDState struct {
	On       *bool    // nil = don't care
	Color    *core.RGB
	BlinkHz  *float64
}

func (a *LEDAssertion) Evaluate(obs *core.Observation) AssertionResult
func (a *LEDAssertion) String() string

// DisplayAssertion validates display content
type DisplayAssertion struct {
	Name     string
	Expected string
}

func (a *DisplayAssertion) Evaluate(obs *core.Observation) AssertionResult
func (a *DisplayAssertion) String() string

// TimingAssertion validates boot timing
type TimingAssertion struct {
	MaxDurationMs int64
}

func (a *TimingAssertion) Evaluate(obs *core.Observation) AssertionResult
func (a *TimingAssertion) String() string
```

Evaluation logic:
- LEDAssertion: Find matching LED signal by name (case-insensitive comparison). If no match found AND exactly one LED exists in observation, fall back to that LED. Check state (on/off), color (if specified), blink rate (if specified). Pass if all specified fields match.
- DisplayAssertion: Find matching Display signal by name. Use strings.Contains(actual, expected) for text matching (OCR is noisy, exact match too brittle).
- TimingAssertion: Find BootTimingSignal, pass if duration <= MaxDurationMs. If BootTimingSignal missing, fail gracefully: Passed=false, Confidence=0.0, Message="boot timing signal not present (did you capture from power-on?)".
- All: Use confidence from signal for result confidence. If signal not found (except Timing case above), fail with confidence 0.0.
  </action>
  <verify>go build ./internal/assertions succeeds without errors</verify>
  <done>Assertion types defined, Evaluate() methods return AssertionResult, String() methods return human-readable representation</done>
</task>

<task type="auto">
  <name>Task 2: Implement DSL parser for assertion syntax</name>
  <files>internal/assertions/parser.go</files>
  <action>
Create DSL parser for simple assertion syntax:

**Syntax:**
- LED assertions: `LED.<name> <state>` where state = `ON` | `OFF` | `BLINK <frequency>Hz` | `COLOR RGB(<r>,<g>,<b>)`
- Display assertions: `Display.<name> "<text>"`
- Timing assertions: `BootTime < <milliseconds>ms`

**Examples:**
- `LED.power ON`
- `LED.status BLINK 2Hz`
- `LED.indicator COLOR RGB(255,0,0)`
- `Display.oled "Ready v1.0"`
- `BootTime < 3000ms`

**Parser implementation:**
```go
package assertions

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"
)

// Parse converts DSL string to Assertion
func Parse(dsl string) (Assertion, error) {
	dsl = strings.TrimSpace(dsl)

	// LED patterns
	if strings.HasPrefix(dsl, "LED.") {
		return parseLED(dsl)
	}

	// Display patterns
	if strings.HasPrefix(dsl, "Display.") {
		return parseDisplay(dsl)
	}

	// Timing patterns
	if strings.HasPrefix(dsl, "BootTime") {
		return parseTiming(dsl)
	}

	return nil, fmt.Errorf("unknown assertion type: %s", dsl)
}

func parseLED(dsl string) (*LEDAssertion, error)
func parseDisplay(dsl string) (*DisplayAssertion, error)
func parseTiming(dsl string) (*TimingAssertion, error)
```

Use regex patterns similar to internal/vision/parser.go approach:
- LED: Match `LED\.([a-z0-9_-]+)\s+(ON|OFF|BLINK\s+[\d.]+Hz|COLOR\s+RGB\((\d+),(\d+),(\d+)\))`
- Display: Match `Display\.([a-z0-9_-]+)\s+"([^"]+)"`
- Timing: Match `BootTime\s+<\s+(\d+)ms`

Return descriptive errors for parse failures.
  </action>
  <verify>
- go build ./internal/assertions succeeds
- Test: Parse("LED.power ON") returns LEDAssertion with Name="power", On=true
- Test: Parse("Display.oled \"Ready\"") returns DisplayAssertion with Name="oled", Expected="Ready"
- Test: Parse("BootTime < 3000ms") returns TimingAssertion with MaxDurationMs=3000
  </verify>
  <done>Parser converts DSL strings to Assertion types, handles all three assertion types, returns descriptive errors for invalid syntax</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` compiles all packages without errors
- [ ] Assertion types implement Assertion interface
- [ ] Parser handles all three assertion syntaxes
- [ ] Evaluate() returns AssertionResult with pass/fail status
- [ ] Test manually: Parse and evaluate sample assertions
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No build errors
- Assertion types can evaluate observations
- DSL parser converts strings to assertions
- Ready for CLI assert command integration
  </success_criteria>

<output>
After completion, create `.planning/phases/02-assertions/02-01-SUMMARY.md`:

# Phase 2 Plan 1: DSL and Assertions Summary

**[Substantive one-liner - what assertion capabilities shipped]**

## Accomplishments

- Assertion types for LED, Display, and Timing validation
- DSL parser for human-readable assertion syntax
- Evaluation logic comparing observed vs expected state
- AssertionResult with pass/fail, confidence, and messages

## Files Created/Modified

- `internal/assertions/types.go` - Assertion types and evaluation
- `internal/assertions/parser.go` - DSL parser

## Decisions Made

[Key decisions and rationale, or "None - followed plan"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Ready for 02-02: CLI assert command. Assertion engine operational, ready for command-line integration.
</output>
