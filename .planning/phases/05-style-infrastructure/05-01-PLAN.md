---
phase: 05-style-infrastructure
plan: 01
type: execute
---

<objective>
Build BARR-C rule engine with C parser integration for style checking embedded firmware code.

Purpose: Establish the foundation for professional code style enforcement. Generated firmware must follow BARR-C Embedded C Coding Standard to be production-ready and pass code review. This is the key differentiator vs Embedder (which generates generic AI code).

Output: Working rule engine that can parse C code and detect BARR-C violations (naming conventions, type safety, magic numbers, const correctness).
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@docs/Percepta_full.md

**v2.0 Context:**
- v1.0 shipped perception kernel (observe/assert/diff) - COMPLETE
- v2.0 goal: Generate hardware-validated, style-compliant firmware
- Key innovation: 100% working code (validated) vs Embedder's 95% compiles
- This phase: Style checker ensures generated code follows BARR-C standards

**BARR-C Standard (from full PRD):**
- Naming: Module_Function() format, snake_case variables, UPPER_SNAKE constants
- Types: Use stdint.h (uint8_t not unsigned char)
- No magic numbers: All constants must be #define
- Const correctness: const uint8_t* not uint8_t*
- Doxygen comments: /** ... */ for all functions
- Static allocation: No malloc/free
- Explicit casts: (uint16_t)value

**Architecture decision:**
Use tree-sitter-c for Go to parse C AST. Tree-sitter is:
- Fast, incremental, robust
- Well-maintained with C grammar
- Go bindings available: github.com/smacker/go-tree-sitter
- Industry standard (used by GitHub, etc.)

**Tech stack available from v1.0:**
- Go binary architecture (cmd/percepta, internal packages)
- Cobra for CLI commands
- Viper for configuration
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define BARR-C rule structure and types</name>
  <files>internal/style/types.go, internal/style/rules.go</files>
  <action>
Create internal/style package with core types:

```go
type Rule struct {
    ID string
    Name string
    Severity string // "error", "warning"
    Category string // "naming", "types", "safety", etc.
}

type Violation struct {
    Rule Rule
    File string
    Line int
    Column int
    Message string
    Suggestion string // auto-fix suggestion if available
}

type Checker interface {
    Check(node *sitter.Node, source []byte) []Violation
}
```

Define BARR-C rule constants in rules.go (use const, not map):
- RuleFunctionNaming: Module_Function() format
- RuleVariableNaming: snake_case
- RuleConstantNaming: UPPER_SNAKE
- RuleStdintTypes: Prefer uint8_t over unsigned char
- RuleMagicNumbers: No hardcoded numbers (except 0, 1)
- RuleConstPointers: const uint8_t* not uint8_t*

Use descriptive errors, not generic. Example:
"Function 'foo' should use Module_Function format (got: foo)" not "naming violation"
  </action>
  <verify>go build ./internal/style works, types are well-defined</verify>
  <done>Rule and Violation types exist, BARR-C rule constants defined, Checker interface declared</done>
</task>

<task type="auto">
  <name>Task 2: Integrate tree-sitter-c parser</name>
  <files>internal/style/parser.go, go.mod</files>
  <action>
Add dependencies:
```bash
go get github.com/smacker/go-tree-sitter@latest
go get github.com/smacker/go-tree-sitter/c@latest
```

Create parser.go:
```go
type Parser struct {
    parser *sitter.Parser
}

func NewParser() *Parser {
    parser := sitter.NewParser()
    parser.SetLanguage(c.GetLanguage())
    return &Parser{parser: parser}
}

func (p *Parser) Parse(source []byte) (*sitter.Tree, error) {
    tree := p.parser.Parse(nil, source)
    if tree == nil {
        return nil, errors.New("failed to parse C code")
    }
    return tree, nil
}

// Helper to traverse AST
func (p *Parser) WalkTree(tree *sitter.Tree, visitor func(*sitter.Node)) {
    cursor := sitter.NewTreeCursor(tree.RootNode())
    // Use cursor to traverse nodes
    // Call visitor(node) for each node
}
```

Focus on extracting:
- Function declarations (for naming checks)
- Variable declarations (for naming and type checks)
- Numeric literals (for magic number detection)
- Pointer declarations (for const checks)

Use tree-sitter query patterns (from C grammar) to find specific node types. Document query examples in comments.
  </action>
  <verify>go build ./internal/style works, can parse simple C code: `int main() { return 0; }`</verify>
  <done>Parser successfully parses C code into AST, WalkTree function works, can extract function/variable nodes</done>
</task>

<task type="auto">
  <name>Task 3: Implement core BARR-C checkers</name>
  <files>internal/style/naming_checker.go, internal/style/types_checker.go, internal/style/checker.go</files>
  <action>
Create naming_checker.go implementing Checker interface:

```go
type NamingChecker struct{}

func (n *NamingChecker) Check(tree *sitter.Tree, source []byte) []Violation {
    var violations []Violation

    // Use tree-sitter query to find function declarations
    // Example query: "(function_declarator (identifier) @func_name)"
    // For each function:
    //   - Extract name
    //   - Check against regex: ^[A-Z][a-zA-Z0-9]*_[A-Z][a-zA-Z0-9]*$
    //   - If no match, create Violation with suggestion

    // Similarly for variables (snake_case) and constants (UPPER_SNAKE)

    return violations
}
```

Create types_checker.go for type safety:
- Detect "unsigned char" → suggest uint8_t
- Detect "unsigned short" → suggest uint16_t
- Detect "unsigned int" → suggest uint32_t
- Check for missing const on pointer parameters

Create checker.go to orchestrate:
```go
type StyleChecker struct {
    checkers []Checker
}

func NewStyleChecker() *StyleChecker {
    return &StyleChecker{
        checkers: []Checker{
            &NamingChecker{},
            &TypesChecker{},
        },
    }
}

func (s *StyleChecker) CheckFile(filepath string) ([]Violation, error) {
    source, _ := os.ReadFile(filepath)
    parser := NewParser()
    tree, _ := parser.Parse(source)

    var allViolations []Violation
    for _, checker := range s.checkers {
        violations := checker.Check(tree, source)
        allViolations = append(allViolations, violations...)
    }
    return allViolations, nil
}
```

Use regex for naming (fast, sufficient for MVP). Tree-sitter gives us line/column positions.

AVOID: Complex AST manipulations in v1. Focus on detection, not transformation yet.
  </action>
  <verify>Write test C file with violations, run CheckFile(), violations detected with correct line numbers</verify>
  <done>NamingChecker and TypesChecker work, StyleChecker orchestrates multiple checkers, violations include line/column/message/suggestion</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./internal/style` succeeds
- [ ] `go test ./internal/style` passes (if tests added)
- [ ] Can parse sample C code with tree-sitter
- [ ] Naming violations detected (function, variable, constant)
- [ ] Type violations detected (unsigned char vs uint8_t)
- [ ] Violations include line numbers and suggestions
</verification>

<success_criteria>

- Rule and Violation types defined
- tree-sitter-c integrated and working
- Parser can extract function/variable declarations from C AST
- NamingChecker detects Module_Function violations
- TypesChecker detects stdint.h violations
- StyleChecker orchestrates multiple checkers
- Ready for 05-02 (auto-fix + CLI)
</success_criteria>

<output>
After completion, create `.planning/phases/05-style-infrastructure/05-01-SUMMARY.md` following the summary.md template.

Include:
- What BARR-C rules are implemented
- Which checkers are working
- Example violations detected
- Integration notes for 05-02
</output>
