---
phase: 05-style-infrastructure
plan: 02
type: execute
---

<objective>
Add auto-fix engine and CLI command for style checking, completing the style infrastructure.

Purpose: Enable automatic violation fixes where possible (reducing manual work) and provide discoverable CLI interface. Users can run `percepta style-check` on generated firmware to validate BARR-C compliance before review.

Output: Working `percepta style-check` command with --fix flag that auto-corrects violations where possible.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-style-infrastructure/05-01-SUMMARY.md
@docs/Percepta_full.md

**From 05-01:**
- Rule and Violation types defined
- tree-sitter-c parser working
- NamingChecker and TypesChecker implemented
- StyleChecker can detect violations

**Tech stack available:**
- Cobra for CLI commands
- internal/style package with working checkers

**Auto-fix strategy (from full PRD):**
Fix where deterministic:
- Function names: Module_Function format (regex replace)
- Type replacements: unsigned char → uint8_t (string replace)
- Doxygen templates: Insert /** ... */ before functions

Don't fix (require manual review):
- Magic numbers (need semantic names, not auto-generated)
- Const correctness (affects signatures, needs careful review)

**CLI design:**
```bash
percepta style-check <file.c>              # Check only, report violations
percepta style-check <file.c> --fix        # Auto-fix where possible, report remaining
percepta style-check <directory> --fix     # Recursive check + fix
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build auto-fix engine</name>
  <files>internal/style/fixer.go, internal/style/naming_checker.go (update), internal/style/types_checker.go (update)</files>
  <action>
Create fixer.go:

```go
type Fixer interface {
    // Returns fixed source if applicable, or original if no fix
    Fix(violation Violation, source []byte) ([]byte, bool)
}

type NamingFixer struct{}

func (n *NamingFixer) Fix(v Violation, source []byte) ([]byte, bool) {
    // Only fix function names, not variables/constants (too risky without context)
    if v.Rule.ID != "RuleFunctionNaming" {
        return source, false
    }

    // Use v.Line and v.Column to locate function name
    // Apply regex replacement to enforce Module_Function format
    // Return modified source

    return source, false // placeholder
}

type TypesFixer struct{}

func (t *TypesFixer) Fix(v Violation, source []byte) ([]byte, bool) {
    // Simple string replacements:
    // "unsigned char" → "uint8_t"
    // "unsigned short" → "uint16_t"
    // "unsigned int" → "uint32_t"
    // "unsigned long" → "uint32_t" (assuming 32-bit embedded)

    // Use v.Line to target specific line, not global replace
    return source, false // placeholder
}

type StyleFixer struct {
    fixers map[string]Fixer
}

func NewStyleFixer() *StyleFixer {
    return &StyleFixer{
        fixers: map[string]Fixer{
            "naming": &NamingFixer{},
            "types":  &TypesFixer{},
        },
    }
}

func (s *StyleFixer) ApplyFixes(violations []Violation, source []byte) []byte {
    current := source
    for _, v := range violations {
        if fixer, ok := s.fixers[v.Rule.Category]; ok {
            if fixed, applied := fixer.Fix(v, current); applied {
                current = fixed
            }
        }
    }
    return current
}
```

Update checkers to include Category in Rule (needed by fixer to route).

AVOID: Complex AST rewrites. Use targeted string replacements with line/column awareness. Focus on high-confidence fixes only.

Add #include <stdint.h> automatically if types are fixed and header is missing.
  </action>
  <verify>Create test file with "unsigned char x;" → run fixer → result is "uint8_t x;" with #include added</verify>
  <done>NamingFixer and TypesFixer work, StyleFixer orchestrates fixes, source is modified in-place correctly, #include injection works</done>
</task>

<task type="auto">
  <name>Task 2: Add percepta style-check CLI command</name>
  <files>cmd/percepta/style.go, cmd/percepta/main.go (update)</files>
  <action>
Create style.go following existing Cobra patterns from device.go:

```go
var styleCmd = &cobra.Command{
    Use:   "style-check <file-or-directory>",
    Short: "Check C code for BARR-C compliance",
    Long:  "Validates generated firmware against BARR-C Embedded C Coding Standard. Use --fix to auto-correct violations where possible.",
    Args:  cobra.ExactArgs(1),
    RunE:  runStyleCheck,
}

var fixFlag bool

func init() {
    styleCmd.Flags().BoolVar(&fixFlag, "fix", false, "Auto-fix violations where possible")
}

func runStyleCheck(cmd *cobra.Command, args []string) error {
    path := args[0]

    // Detect if file or directory
    info, err := os.Stat(path)
    if err != nil {
        return fmt.Errorf("path not found: %w", err)
    }

    var files []string
    if info.IsDir() {
        // Walk directory, find *.c and *.h files
        filepath.Walk(path, func(p string, info os.FileInfo, err error) error {
            if strings.HasSuffix(p, ".c") || strings.HasSuffix(p, ".h") {
                files = append(files, p)
            }
            return nil
        })
    } else {
        files = []string{path}
    }

    checker := style.NewStyleChecker()
    fixer := style.NewStyleFixer()

    totalViolations := 0
    for _, file := range files {
        violations, _ := checker.CheckFile(file)

        if fixFlag && len(violations) > 0 {
            source, _ := os.ReadFile(file)
            fixed := fixer.ApplyFixes(violations, source)
            os.WriteFile(file, fixed, 0644)

            // Re-check to see remaining violations
            violations, _ = checker.CheckFile(file)
        }

        if len(violations) > 0 {
            fmt.Printf("\n%s:\n", file)
            for _, v := range violations {
                fmt.Printf("  %d:%d %s [%s] %s\n",
                    v.Line, v.Column, v.Rule.Severity, v.Rule.Name, v.Message)
                if v.Suggestion != "" {
                    fmt.Printf("    Suggestion: %s\n", v.Suggestion)
                }
            }
            totalViolations += len(violations)
        }
    }

    if totalViolations == 0 {
        fmt.Println("✅ No style violations found. Code is BARR-C compliant.")
        return nil
    }

    fmt.Printf("\n%d violation(s) found.\n", totalViolations)
    if !fixFlag {
        fmt.Println("\nRun with --fix to auto-correct fixable violations.")
    }
    return nil
}
```

Register in main.go:
```go
rootCmd.AddCommand(styleCmd)
```

Output format matches standard linters (file:line:col severity [rule] message). Easy to parse for CI integration later.

AVOID: Interactive mode in v1. Keep it simple: report or fix.
  </action>
  <verify>percepta style-check ./test.c reports violations, percepta style-check ./test.c --fix applies corrections</verify>
  <done>style-check command works, detects violations, --fix flag applies auto-fixes, output is clear and actionable, exits 0 if clean</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `go build ./cmd/percepta` succeeds
- [ ] `percepta style-check` command exists and shows help
- [ ] Can check a C file and detect violations
- [ ] `--fix` flag auto-corrects naming and type issues
- [ ] Remaining violations are reported clearly
- [ ] Works on both single files and directories
- [ ] Exit code 0 if no violations, non-zero if violations remain
</verification>

<success_criteria>

- Auto-fix engine works for naming and types
- `percepta style-check` CLI command functional
- --fix flag applies corrections automatically
- Clear violation reporting with line numbers
- Directory traversal works (finds all .c/.h files)
- Phase 5 complete: Style infrastructure ready for Phase 6
</success_criteria>

<output>
After completion, create `.planning/phases/05-style-infrastructure/05-02-SUMMARY.md` following the summary.md template.

Include:
- Auto-fix capabilities demonstrated
- CLI usage examples
- Integration readiness for Phase 6 (knowledge graphs)
- Example output showing violations and fixes
- Note: This completes v2.0 Phase 5 - style checker ready to validate generated code
</output>
