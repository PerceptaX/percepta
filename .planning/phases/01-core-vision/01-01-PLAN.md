---
phase: 01-core-vision
plan: 01
type: execute
---

<objective>
Initialize Go project with core types and SQLite storage foundation.

Purpose: Establish the data model and persistence layer that all other components depend on. This is the kernel - Signal, Observation, and storage primitives.

Output: Working Go module with core types, SQLite schema, and storage driver that can save/query observations.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-vision/DISCOVERY.md

**Tech stack selected:**
- Go 1.22+
- `modernc.org/sqlite` (pure Go, no cgo)
- `github.com/spf13/cobra` (CLI framework)
- `github.com/spf13/viper` (config management)

**Key constraints:**
- Zero runtime dependencies (single binary)
- Cross-platform (Linux, macOS, Windows)
- No raw image storage in v1 (signals only)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Go module and project structure</name>
  <files>go.mod, go.sum, cmd/percepta/main.go, internal/core/types.go, internal/storage/sqlite.go, pkg/percepta/percepta.go</files>
  <action>
Run `go mod init github.com/perceptumx/percepta` to initialize module.

Create project structure:
- `cmd/percepta/main.go` - CLI entrypoint (will use Cobra later)
- `internal/core/types.go` - Core types (Signal, Observation, Session)
- `internal/storage/sqlite.go` - SQLite storage driver
- `pkg/percepta/percepta.go` - Public API (Core struct, Observe/Assert/Diff methods)

Install dependencies:
```bash
go get modernc.org/sqlite@latest
go get github.com/spf13/cobra@latest
go get github.com/spf13/viper@latest
```

Add basic main.go that prints "percepta v0.1.0-alpha" for now.

Do NOT install mattn/go-sqlite3 (uses cgo). Use modernc.org/sqlite (pure Go) as per DISCOVERY.md.
  </action>
  <verify>
- `go mod tidy` succeeds
- `go build ./cmd/percepta` produces binary
- `./percepta` prints version string
- `go.mod` contains modernc.org/sqlite, cobra, viper
  </verify>
  <done>Go module initialized, project structure created, dependencies installed, binary builds successfully</done>
</task>

<task type="auto">
  <name>Task 2: Define core types (Signal, Observation, Session)</name>
  <files>internal/core/types.go</files>
  <action>
Create core data types in `internal/core/types.go`:

```go
package core

import "time"

// Signal interface - LED, Display, or Boot timing
type Signal interface {
    Type() string
    State() interface{}
}

// LEDSignal represents LED state observation
type LEDSignal struct {
    Name       string  `json:"name"`
    On         bool    `json:"on"`
    Color      RGB     `json:"color,omitempty"`
    Brightness uint8   `json:"brightness,omitempty"`
    BlinkHz    float64 `json:"blink_hz,omitempty"`
    Confidence float64 `json:"confidence"`
}

func (l LEDSignal) Type() string { return "led" }
func (l LEDSignal) State() interface{} { return l }

// RGB color
type RGB struct {
    R uint8 `json:"r"`
    G uint8 `json:"g"`
    B uint8 `json:"b"`
}

// DisplaySignal represents display content observation
type DisplaySignal struct {
    Name       string  `json:"name"`
    Text       string  `json:"text"`
    Confidence float64 `json:"confidence"`
}

func (d DisplaySignal) Type() string { return "display" }
func (d DisplaySignal) State() interface{} { return d }

// BootTimingSignal represents boot sequence timing
type BootTimingSignal struct {
    DurationMs int64   `json:"duration_ms"`
    Confidence float64 `json:"confidence"`
}

func (b BootTimingSignal) Type() string { return "boot_timing" }
func (b BootTimingSignal) State() interface{} { return b }

// Observation is a snapshot of hardware state at a point in time
type Observation struct {
    ID           string    `json:"id"`
    DeviceID     string    `json:"device_id"`
    FirmwareHash string    `json:"firmware_hash,omitempty"`
    Timestamp    time.Time `json:"timestamp"`
    Signals      []Signal  `json:"signals"`
}

// Session is a series of observations (not used in MVP, but define for future)
type Session struct {
    ID           string        `json:"id"`
    DeviceID     string        `json:"device_id"`
    StartTime    time.Time     `json:"start_time"`
    EndTime      time.Time     `json:"end_time,omitempty"`
    Observations []Observation `json:"observations"`
}
```

Use json tags for future JSON marshaling. Signal interface allows polymorphism for LED/Display/Boot types.
  </action>
  <verify>`go build ./internal/core` succeeds without errors</verify>
  <done>Core types defined with Signal interface, LEDSignal, DisplaySignal, BootTimingSignal, Observation, Session structs</done>
</task>

<task type="auto">
  <name>Task 3: Implement SQLite storage driver</name>
  <files>internal/storage/sqlite.go, internal/storage/driver.go</files>
  <action>
Create `internal/storage/driver.go` with StorageDriver interface:

```go
package storage

import "github.com/perceptumx/percepta/internal/core"

type QueryFilter struct {
    DeviceID     string
    FirmwareHash string
    Since        *time.Time
    Until        *time.Time
    Limit        int
}

type StorageDriver interface {
    Init() error
    Save(obs core.Observation) error
    Query(filter QueryFilter) ([]core.Observation, error)
    Close() error
}
```

Create `internal/storage/sqlite.go` implementing SQLiteDriver:

```go
package storage

import (
    "database/sql"
    "encoding/json"
    _ "modernc.org/sqlite"  // Pure Go SQLite driver
    "github.com/perceptumx/percepta/internal/core"
)

type SQLiteDriver struct {
    db *sql.DB
    path string
}

func NewSQLiteDriver(dbPath string) *SQLiteDriver {
    return &SQLiteDriver{path: dbPath}
}

func (d *SQLiteDriver) Init() error {
    db, err := sql.Open("sqlite", d.path)
    if err != nil {
        return err
    }
    d.db = db

    schema := `
    CREATE TABLE IF NOT EXISTS observations (
        id TEXT PRIMARY KEY,
        device_id TEXT NOT NULL,
        firmware_hash TEXT,
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        signals JSON NOT NULL,
        metadata JSON
    );

    CREATE INDEX IF NOT EXISTS idx_device_firmware
        ON observations(device_id, firmware_hash);
    CREATE INDEX IF NOT EXISTS idx_timestamp
        ON observations(timestamp);
    `

    _, err = d.db.Exec(schema)
    return err
}

func (d *SQLiteDriver) Save(obs core.Observation) error {
    signalsJSON, err := json.Marshal(obs.Signals)
    if err != nil {
        return err
    }

    _, err = d.db.Exec(
        `INSERT INTO observations (id, device_id, firmware_hash, timestamp, signals)
         VALUES (?, ?, ?, ?, ?)`,
        obs.ID, obs.DeviceID, obs.FirmwareHash, obs.Timestamp, signalsJSON,
    )
    return err
}

func (d *SQLiteDriver) Query(filter QueryFilter) ([]core.Observation, error) {
    query := "SELECT id, device_id, firmware_hash, timestamp, signals FROM observations WHERE 1=1"
    args := []interface{}{}

    if filter.DeviceID != "" {
        query += " AND device_id = ?"
        args = append(args, filter.DeviceID)
    }
    if filter.FirmwareHash != "" {
        query += " AND firmware_hash = ?"
        args = append(args, filter.FirmwareHash)
    }
    if filter.Limit > 0 {
        query += " LIMIT ?"
        args = append(args, filter.Limit)
    }

    rows, err := d.db.Query(query, args...)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var observations []core.Observation
    for rows.Next() {
        var obs core.Observation
        var signalsJSON string

        err := rows.Scan(&obs.ID, &obs.DeviceID, &obs.FirmwareHash, &obs.Timestamp, &signalsJSON)
        if err != nil {
            return nil, err
        }

        // Parse signals JSON
        json.Unmarshal([]byte(signalsJSON), &obs.Signals)
        observations = append(observations, obs)
    }

    return observations, nil
}

func (d *SQLiteDriver) Close() error {
    if d.db != nil {
        return d.db.Close()
    }
    return nil
}
```

Use modernc.org/sqlite (not mattn/go-sqlite3) to avoid cgo. Store signals as JSON for MVP flexibility. Basic query filtering by device_id, firmware_hash, limit.
  </action>
  <verify>
- `go build ./internal/storage` succeeds
- Create test: initialize driver, save observation, query back, verify fields match
- Run: `go test ./internal/storage`
  </verify>
  <done>SQLite storage driver implemented with Init, Save, Query, Close methods. Schema created with indexes. Signals stored as JSON.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go mod tidy` succeeds
- [ ] `go build ./...` compiles all packages
- [ ] Project structure matches: cmd/, internal/core/, internal/storage/, pkg/
- [ ] Binary runs and prints version
- [ ] Core types defined (Signal interface, LEDSignal, DisplaySignal, BootTimingSignal, Observation)
- [ ] SQLite driver can init schema, save observation, query back
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No build errors
- Go module initialized with modernc.org/sqlite (pure Go)
- Core types define perception data model
- SQLite storage driver functional
  </success_criteria>

<output>
After completion, create `.planning/phases/01-core-vision/01-01-SUMMARY.md`:

# Phase 1 Plan 1: Foundation Summary

**Go module initialized with core perception types and SQLite storage driver**

## Accomplishments

- Go project structure established (cmd/, internal/, pkg/)
- Core types defined: Signal interface, LEDSignal, DisplaySignal, BootTimingSignal, Observation, Session
- SQLite storage driver implemented with schema, indexing, JSON signal storage
- Dependencies: modernc.org/sqlite (pure Go), cobra, viper

## Files Created/Modified

- `go.mod`, `go.sum` - Module definition with pure Go dependencies
- `cmd/percepta/main.go` - CLI entrypoint
- `internal/core/types.go` - Core perception data types
- `internal/storage/driver.go` - Storage interface
- `internal/storage/sqlite.go` - SQLite implementation

## Decisions Made

- **modernc.org/sqlite over mattn/go-sqlite3**: Pure Go for easy cross-compilation, no cgo
- **Signals as JSON**: Flexible storage, simpler queries for MVP vs normalized tables
- **Internal vs pkg**: Core/storage are internal (implementation), pkg/percepta will be public API

## Issues Encountered

(None expected - greenfield Go project)

## Next Phase Readiness

Ready for 01-02: Claude Vision driver + camera capture. Storage layer can persist observations.
</output>
