---
phase: 01-core-vision
plan: 01
type: execute
---

<objective>
Initialize Go project with core types and driver interfaces.

Purpose: Establish the data model and abstractions that enable swappable implementations. This is the kernel - Signal, Observation, and driver interfaces with in-memory stubs.

Output: Working Go module with core types, VisionDriver/CameraDriver/StorageDriver interfaces, and in-memory storage stub.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-vision/DISCOVERY.md

**Tech stack selected:**
- Go 1.22+
- `github.com/spf13/cobra` (CLI framework)
- `github.com/spf13/viper` (config management)

**Key constraints:**
- Zero runtime dependencies (single binary)
- Cross-platform (Linux, macOS, Windows)
- No raw image storage in v1 (signals only)
- Driver interfaces must be platform-agnostic
- MVP priority: observe() accuracy, not persistence
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Go module and project structure</name>
  <files>go.mod, go.sum, cmd/percepta/main.go, internal/core/types.go, internal/core/interfaces.go, pkg/percepta/percepta.go</files>
  <action>
Run `go mod init github.com/perceptumx/percepta` to initialize module.

Create project structure:
- `cmd/percepta/main.go` - CLI entrypoint (will use Cobra later)
- `internal/core/types.go` - Core types (Signal, Observation)
- `internal/core/interfaces.go` - Driver interfaces (VisionDriver, CameraDriver, StorageDriver)
- `pkg/percepta/percepta.go` - Public API (Core struct, Observe method)

Install dependencies:
```bash
go get github.com/spf13/cobra@latest
go get github.com/spf13/viper@latest
```

Add basic main.go that prints "percepta v0.1.0-alpha" for now.

Do NOT install SQLite or camera libraries yet. Focus on types and interfaces only.
  </action>
  <verify>
- `go mod tidy` succeeds
- `go build ./cmd/percepta` produces binary
- `./percepta` prints version string
- `go.mod` contains cobra, viper (no SQLite, no camera libs yet)
  </verify>
  <done>Go module initialized, project structure created, CLI dependencies installed, binary builds successfully</done>
</task>

<task type="auto">
  <name>Task 2: Define core types and driver interfaces</name>
  <files>internal/core/types.go, internal/core/interfaces.go, internal/core/id.go</files>
  <action>
Create `internal/core/types.go`:

```go
package core

import "time"

// Signal interface - LED, Display, or Boot timing
type Signal interface {
    Type() string
    State() interface{}
}

// LEDSignal represents LED state observation
type LEDSignal struct {
    Name       string  `json:"name"`
    On         bool    `json:"on"`
    Color      RGB     `json:"color,omitempty"`
    Brightness uint8   `json:"brightness,omitempty"`
    BlinkHz    float64 `json:"blink_hz,omitempty"`
    Confidence float64 `json:"confidence"`
}

func (l LEDSignal) Type() string { return "led" }
func (l LEDSignal) State() interface{} { return l }

// RGB color
type RGB struct {
    R uint8 `json:"r"`
    G uint8 `json:"g"`
    B uint8 `json:"b"`
}

// DisplaySignal represents display content observation
type DisplaySignal struct {
    Name       string  `json:"name"`
    Text       string  `json:"text"`
    Confidence float64 `json:"confidence"`
}

func (d DisplaySignal) Type() string { return "display" }
func (d DisplaySignal) State() interface{} { return d }

// BootTimingSignal represents boot sequence timing
type BootTimingSignal struct {
    DurationMs int64   `json:"duration_ms"`
    Confidence float64 `json:"confidence"`
}

func (b BootTimingSignal) Type() string { return "boot_timing" }
func (b BootTimingSignal) State() interface{} { return b }

// Observation is a snapshot of hardware state at a point in time
type Observation struct {
    ID           string    `json:"id"`
    DeviceID     string    `json:"device_id"`
    FirmwareHash string    `json:"firmware_hash,omitempty"`
    Timestamp    time.Time `json:"timestamp"`
    Signals      []Signal  `json:"signals"`
}
```

Create `internal/core/interfaces.go` with platform-agnostic interfaces:

```go
package core

// CameraDriver captures frames from physical camera
// Implementation must be platform-specific (V4L2 on Linux, AVFoundation on macOS, etc.)
type CameraDriver interface {
    Open() error
    CaptureFrame() ([]byte, error)  // Returns JPEG bytes
    Close() error
}

// VisionDriver converts camera frames to structured observations
type VisionDriver interface {
    Observe(deviceID string, frame []byte) (*Observation, error)
}

// StorageDriver persists observations
type StorageDriver interface {
    Save(obs Observation) error
    Query(deviceID string, limit int) ([]Observation, error)
}
```

Create `internal/core/id.go`:

```go
package core

import (
    "crypto/rand"
    "encoding/hex"
)

func GenerateID() string {
    b := make([]byte, 16)
    rand.Read(b)
    return hex.EncodeToString(b)
}
```

Driver interfaces are platform-agnostic. CameraDriver returns JPEG bytes (format, not platform-specific API). VisionDriver receives frame bytes, not platform-specific camera object.
  </action>
  <verify>`go build ./internal/core` succeeds without errors</verify>
  <done>Core types and driver interfaces defined. Interfaces are platform-agnostic and swappable. Signal types defined with confidence scores.</done>
</task>

<task type="auto">
  <name>Task 3: Implement in-memory storage stub</name>
  <files>internal/storage/memory.go</files>
  <action>
Create `internal/storage/memory.go` with in-memory storage stub:

```go
package storage

import (
    "fmt"
    "sync"
    "github.com/perceptumx/percepta/internal/core"
)

// MemoryStorage is an in-memory storage stub for MVP
// Observations stored in slice, not persisted
type MemoryStorage struct {
    mu           sync.RWMutex
    observations []core.Observation
}

func NewMemoryStorage() *MemoryStorage {
    return &MemoryStorage{
        observations: make([]core.Observation, 0),
    }
}

func (m *MemoryStorage) Save(obs core.Observation) error {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.observations = append(m.observations, obs)
    return nil
}

func (m *MemoryStorage) Query(deviceID string, limit int) ([]core.Observation, error) {
    m.mu.RLock()
    defer m.mu.RUnlock()

    var filtered []core.Observation
    for _, obs := range m.observations {
        if deviceID == "" || obs.DeviceID == deviceID {
            filtered = append(filtered, obs)
        }
    }

    // Apply limit
    if limit > 0 && len(filtered) > limit {
        filtered = filtered[len(filtered)-limit:]
    }

    return filtered, nil
}

func (m *MemoryStorage) Count() int {
    m.mu.RLock()
    defer m.mu.RUnlock()
    return len(m.observations)
}
```

In-memory storage for MVP. Thread-safe with mutex. No persistence - observations lost on restart. SQLite will be added later after observe() works. This keeps Phase 1 focused on perception accuracy, not persistence.
  </action>
  <verify>
- `go build ./internal/storage` succeeds
- Test: Save observation, Query back, verify returned
- Test: Save multiple, Query with limit, verify count
  </verify>
  <done>In-memory storage stub implemented with Save, Query, Count methods. Thread-safe. No persistence dependency.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go mod tidy` succeeds
- [ ] `go build ./...` compiles all packages
- [ ] Project structure matches: cmd/, internal/core/, internal/storage/, pkg/
- [ ] Binary runs and prints version
- [ ] Core types defined (Signal interface, LEDSignal, DisplaySignal, BootTimingSignal, Observation)
- [ ] Driver interfaces defined (CameraDriver, VisionDriver, StorageDriver)
- [ ] In-memory storage can save and query observations
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No build errors
- Go module initialized with minimal dependencies (cobra, viper)
- Core types define perception data model
- Driver interfaces are platform-agnostic and swappable
- In-memory storage functional (no persistence yet)
  </success_criteria>

<output>
After completion, create `.planning/phases/01-core-vision/01-01-SUMMARY.md`:

# Phase 1 Plan 1: Foundation Summary

**Go module initialized with core types and driver interfaces**

## Accomplishments

- Go project structure established (cmd/, internal/, pkg/)
- Core types defined: Signal interface, LEDSignal, DisplaySignal, BootTimingSignal, Observation
- Driver interfaces defined: CameraDriver, VisionDriver, StorageDriver (platform-agnostic)
- In-memory storage stub implemented (no persistence yet)
- Dependencies: cobra, viper (minimal, no SQLite/camera libs yet)

## Files Created/Modified

- `go.mod`, `go.sum` - Module definition with minimal dependencies
- `cmd/percepta/main.go` - CLI entrypoint
- `internal/core/types.go` - Core perception data types
- `internal/core/interfaces.go` - Platform-agnostic driver interfaces
- `internal/core/id.go` - ID generation utility
- `internal/storage/memory.go` - In-memory storage stub

## Decisions Made

- **Platform-agnostic interfaces**: CameraDriver returns JPEG bytes, not platform-specific API objects. Enables Linux/macOS/Windows implementations without refactor.
- **In-memory storage for MVP**: Focus on observe() accuracy first. SQLite deferred until after perception works.
- **Minimal dependencies**: Only cobra + viper. Camera/Vision libraries come in 01-02.

## Issues Encountered

(None expected - greenfield Go project)

## Next Phase Readiness

Ready for 01-02: Camera + Vision implementation. Interfaces defined, ready for concrete implementations behind abstraction.
</output>
