---
phase: 01-core-vision
plan: 03
type: execute
---

<objective>
Build CLI observe command with structured output formatting.

Purpose: Expose the perception kernel via `percepta observe <device>` command. This is the v1 user interface - developer types command, sees hardware state.

Output: Working `percepta observe <device>` command that captures, stores, and displays observations in readable format.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-vision/DISCOVERY.md
@.planning/phases/01-core-vision/01-01-SUMMARY.md
@.planning/phases/01-core-vision/01-02-SUMMARY.md

**Tech stack from prior plans:**
- Core types: Signal, Observation, LEDSignal, DisplaySignal, BootTimingSignal
- In-memory storage: Save, Query methods (no persistence yet)
- Claude Vision driver: Observe(deviceID, frame) returns Observation
- Camera driver: V4L2Camera implements core.CameraDriver (Linux)

**CLI framework:**
- `github.com/spf13/cobra` - Command structure
- `github.com/spf13/viper` - Config file (~/.config/percepta/config.yaml)

**Output format requirements:**
- Human-readable (not just JSON dump)
- Show: device, timestamp, signals with confidence
- Store observation in memory (for Phase 1 validation)
- Print observation count to show it's being stored
- MVP goal: Verify observe() accuracy, not persistence
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire up Core API and config loading</name>
  <files>pkg/percepta/percepta.go, internal/config/config.go</files>
  <action>
Create `internal/config/config.go` for YAML config:

```go
package config

import (
    "fmt"
    "os"
    "path/filepath"

    "github.com/spf13/viper"
)

type Config struct {
    Vision  VisionConfig
    Storage StorageConfig
    Devices map[string]DeviceConfig
}

type VisionConfig struct {
    Provider string `mapstructure:"provider"`
    APIKey   string `mapstructure:"api_key"`
}

type StorageConfig struct {
    Backend string `mapstructure:"backend"`
    Path    string `mapstructure:"path"`
}

type DeviceConfig struct {
    Type     string `mapstructure:"type"`
    CameraID string `mapstructure:"camera_id"`
}

func Load() (*Config, error) {
    homeDir, err := os.UserHomeDir()
    if err != nil {
        return nil, err
    }

    configPath := filepath.Join(homeDir, ".config", "percepta")
    viper.AddConfigPath(configPath)
    viper.SetConfigName("config")
    viper.SetConfigType("yaml")

    // Set defaults (vision only - no storage in Phase 1)
    viper.SetDefault("vision.provider", "claude")

    // Try to read config (OK if doesn't exist)
    viper.ReadInConfig()

    // Env var overrides
    viper.SetEnvPrefix("PERCEPTA")
    viper.AutomaticEnv()

    var cfg Config
    if err := viper.Unmarshal(&cfg); err != nil {
        return nil, err
    }

    // Override APIKey from env if set
    if apiKey := os.Getenv("ANTHROPIC_API_KEY"); apiKey != "" {
        cfg.Vision.APIKey = apiKey
    }

    return &cfg, nil
}
```

Update `pkg/percepta/percepta.go` as public API:

```go
package percepta

import (
    "fmt"
    "github.com/perceptumx/percepta/internal/core"
    "github.com/perceptumx/percepta/internal/camera"
    "github.com/perceptumx/percepta/internal/vision"
    "github.com/perceptumx/percepta/internal/storage"
)

type Core struct {
    camera  core.CameraDriver
    vision  core.VisionDriver
    storage *storage.MemoryStorage
}

func NewCore(cameraPath string) (*Core, error) {
    // Initialize camera driver (Linux V4L2 for now)
    cameraDriver := camera.NewV4L2Camera(cameraPath)

    // Initialize vision driver
    visionDriver, err := vision.NewClaudeVision()
    if err != nil {
        return nil, fmt.Errorf("vision init failed: %w", err)
    }

    // Initialize in-memory storage
    storageDriver := storage.NewMemoryStorage()

    return &Core{
        camera:  cameraDriver,
        vision:  visionDriver,
        storage: storageDriver,
    }, nil
}

func (c *Core) Observe(deviceID string) (*core.Observation, error) {
    // Open camera
    if err := c.camera.Open(); err != nil {
        return nil, fmt.Errorf("camera open failed: %w", err)
    }
    defer c.camera.Close()

    // Capture frame
    frame, err := c.camera.CaptureFrame()
    if err != nil {
        return nil, fmt.Errorf("camera capture failed: %w", err)
    }

    // Analyze frame with vision
    obs, err := c.vision.Observe(deviceID, frame)
    if err != nil {
        return nil, fmt.Errorf("vision analysis failed: %w", err)
    }

    // Save to storage
    if err := c.storage.Save(*obs); err != nil {
        return nil, fmt.Errorf("storage failed: %w", err)
    }

    return obs, nil
}

func (c *Core) ObservationCount() int {
    return c.storage.Count()
}
```

Config loads from ~/.config/percepta/config.yaml with sensible defaults. Core API orchestrates camera → vision → storage. Clean separation: camera captures, vision analyzes, storage persists.
  </action>
  <verify>
- `go build ./pkg/percepta` succeeds
- `go build ./internal/config` succeeds
- Test: Load config (OK if file missing), verify defaults set
  </verify>
  <done>Core API implemented with Observe() method. Config loading from YAML with env var overrides and defaults.</done>
</task>

<task type="auto">
  <name>Task 2: Implement CLI observe command with formatted output</name>
  <files>cmd/percepta/main.go, cmd/percepta/observe.go</files>
  <action>
Update `cmd/percepta/main.go`:

```go
package main

import (
    "fmt"
    "os"

    "github.com/spf13/cobra"
)

var rootCmd = &cobra.Command{
    Use:   "percepta",
    Short: "Perception kernel for physical hardware",
    Long:  "Percepta uses computer vision to observe, validate, and compare real-world hardware behavior.",
}

func main() {
    if err := rootCmd.Execute(); err != nil {
        fmt.Fprintln(os.Stderr, err)
        os.Exit(1)
    }
}

func init() {
    rootCmd.AddCommand(observeCmd)
}
```

Create `cmd/percepta/observe.go`:

```go
package main

import (
    "fmt"
    "os"
    "time"

    "github.com/spf13/cobra"
    "github.com/perceptumx/percepta/internal/config"
    "github.com/perceptumx/percepta/internal/core"
    "github.com/perceptumx/percepta/pkg/percepta"
)

var observeCmd = &cobra.Command{
    Use:   "observe <device>",
    Short: "Capture current hardware state",
    Long:  "Captures webcam frame, analyzes with Claude Vision, and stores observation.",
    Args:  cobra.ExactArgs(1),
    RunE:  runObserve,
}

func runObserve(cmd *cobra.Command, args []string) error {
    deviceID := args[0]

    // Load config
    cfg, err := config.Load()
    if err != nil {
        return fmt.Errorf("config load failed: %w", err)
    }

    // Get camera path for device
    cameraPath := "/dev/video0"  // Default
    if deviceCfg, ok := cfg.Devices[deviceID]; ok {
        if deviceCfg.CameraID != "" {
            cameraPath = deviceCfg.CameraID
        }
    }

    // Initialize Core
    perceptaCore, err := percepta.NewCore(cameraPath)
    if err != nil {
        return err
    }

    // Capture observation
    fmt.Fprintf(os.Stderr, "Observing %s via %s...\n", deviceID, cameraPath)
    obs, err := perceptaCore.Observe(deviceID)
    if err != nil {
        return err
    }

    // Format output
    printObservation(obs, perceptaCore.ObservationCount())

    return nil
}

func printObservation(obs *core.Observation, count int) {
    fmt.Printf("✅ Observation captured: %s\n", obs.ID)
    fmt.Printf("Device: %s\n", obs.DeviceID)
    fmt.Printf("Timestamp: %s\n", obs.Timestamp.Format(time.RFC3339))
    fmt.Printf("\n")

    if len(obs.Signals) == 0 {
        fmt.Println("No signals detected")
        return
    }

    fmt.Printf("Signals (%d):\n", len(obs.Signals))
    for i, signal := range obs.Signals {
        switch s := signal.(type) {
        case core.LEDSignal:
            state := "OFF"
            if s.On {
                state = "ON"
            }
            fmt.Printf("  %d. LED '%s': %s", i+1, s.Name, state)
            if s.BlinkHz > 0 {
                fmt.Printf(" (blinking at %.2f Hz)", s.BlinkHz)
            }
            if s.Color.R > 0 || s.Color.G > 0 || s.Color.B > 0 {
                fmt.Printf(" [RGB(%d,%d,%d)]", s.Color.R, s.Color.G, s.Color.B)
            }
            fmt.Printf(" [confidence: %.2f]\n", s.Confidence)

        case core.DisplaySignal:
            fmt.Printf("  %d. Display '%s': \"%s\" [confidence: %.2f]\n",
                i+1, s.Name, s.Text, s.Confidence)

        case core.BootTimingSignal:
            fmt.Printf("  %d. Boot timing: %dms [confidence: %.2f]\n",
                i+1, s.DurationMs, s.Confidence)
        }
    }

    fmt.Printf("\nStored in memory (%d total observations)\n", count)
}
```

Command accepts device ID, loads config, initializes Core (camera + vision + memory storage), captures observation, prints formatted output. Output shows ID, timestamp, each signal with type-specific formatting and confidence. No persistence yet - focus on perception accuracy.
  </action>
  <verify>
- `go build ./cmd/percepta` produces binary
- `./percepta observe --help` shows usage
- If camera + API key available: `./percepta observe test-device` captures observation and displays formatted output
- Check: Output includes observation ID, device, timestamp, signal details, confidence scores
  </verify>
  <done>CLI observe command implemented. Loads config, captures observation, saves to SQLite, displays human-readable output with signal details and confidence scores.</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `go build ./cmd/percepta` succeeds
- [ ] Binary runs: `./percepta observe <device>` executes without errors (if deps available)
- [ ] Output format is human-readable (not raw JSON)
- [ ] Observation stored in memory (count increments on subsequent calls)
- [ ] Config loads from ~/.config/percepta/config.yaml (or uses defaults if missing)
- [ ] ANTHROPIC_API_KEY env var respected
- [ ] Phase 1 goal met: `percepta observe <device>` works end-to-end
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- CLI observe command functional
- Config loading with YAML + env vars + defaults
- Formatted output shows signals, confidence, observation ID
- In-memory storage working (observations persist within session)
- **Phase 1 complete**: percepta observe <device> works end-to-end with 95%+ accuracy goal
  </success_criteria>

<output>
After completion, create `.planning/phases/01-core-vision/01-03-SUMMARY.md`:

# Phase 1 Plan 3: CLI Interface Summary

**CLI observe command operational - Phase 1 complete**

## Accomplishments

- Core API (pkg/percepta) orchestrates camera → vision → storage
- Config loading from ~/.config/percepta/config.yaml with defaults
- Cobra CLI with `observe <device>` command
- Human-readable output formatting for LED/Display/Boot signals
- End-to-end flow: CLI → config → camera → Vision API → parsing → memory → output
- In-memory storage (no persistence yet - MVP focuses on accuracy)

## Files Created/Modified

- `pkg/percepta/percepta.go` - Public Core API with Observe() and ObservationCount()
- `internal/config/config.go` - Viper-based config loading
- `cmd/percepta/main.go` - Cobra root command
- `cmd/percepta/observe.go` - Observe command implementation

## Decisions Made

- **Human-readable output over JSON**: Better UX for alpha users. JSON export can be added later.
- **Config file optional**: Works with defaults if ~/.config/percepta/config.yaml missing.
- **Env vars override config**: ANTHROPIC_API_KEY > config.yaml for flexibility.
- **In-memory storage for Phase 1**: Prove observe() accuracy before adding persistence. SQLite comes after validation.

## Issues Encountered

(Note any camera permissions, API failures, or output formatting tweaks discovered)

## Next Phase Readiness

**Phase 1 complete! Ready for Phase 2: Assertions.**

Phase 1 delivered:
- ✅ percepta observe <device> working end-to-end
- ✅ Claude Vision API integration with Sonnet 4.5
- ✅ LED/Display signal extraction with confidence scores
- ✅ Platform-agnostic architecture (interfaces enable macOS/Windows later)
- ✅ Parser isolated and swappable (regex now, structured output later)
- ✅ In-memory storage (persistence deferred to post-Phase 1)

Success criteria: 95%+ accuracy on LED/display/boot signals (to be validated with alpha testing).

**Note:** Persistence intentionally omitted from Phase 1. SQLite will be added after observe() accuracy is validated with real hardware.
</output>
