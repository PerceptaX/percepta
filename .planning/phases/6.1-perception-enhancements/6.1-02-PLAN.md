---
phase: 6.1-perception-enhancements
plan: 02
type: execute
---

<objective>
Add temporal smoothing for noisy observations and lock JSON schema to prevent breaking changes.

Purpose: Make perception data stable and reliable for Phase 7's validation loop. Temporal smoothing filters out transient noise (single-frame glitches), and schema locking ensures downstream tools won't break when observation format changes.

Output: Stable, smoothed observations with locked schema versioning.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/6.1-perception-enhancements/6.1-01-PLAN.md
@internal/core/types.go
@internal/storage/sqlite_storage.go

**From Plan 6.1-01:**
- Multi-frame capture produces reliable LED detections
- Confidence calibration provides quality metrics
- StructuredParser produces deterministic signals

**Temporal smoothing need:**
Even with multi-frame capture, observations can have transient noise:
- Camera glitches (brief overexposure)
- Reflections causing false positives
- OCR errors on display text

Solution: Temporal filter that compares consecutive observations and smooths out single-frame anomalies.

**Schema lock need:**
Current Observation struct has no version field. If we change the structure:
- Add new signal types
- Change field names
- Modify JSON format

Downstream tools (assertions, diffs, codegen) will break.

Solution: Add schema version to Observation, validate on load, support migrations.

**Integration requirements:**
- Temporal smoothing happens at storage layer (before Save)
- Schema validation happens at serialization/deserialization
- Must not break existing observations in SQLite
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add temporal smoothing filter</name>
  <files>internal/filter/temporal_smoother.go (new), internal/filter/temporal_smoother_test.go, pkg/percepta/percepta.go</files>
  <action>
Create temporal smoothing filter that detects and removes transient noise by comparing consecutive observations.

**Create TemporalSmoother:**

```go
// internal/filter/temporal_smoother.go

package filter

import (
	"time"

	"github.com/perceptumx/percepta/internal/core"
)

// TemporalSmoother filters out single-frame anomalies by comparing consecutive observations
type TemporalSmoother struct {
	window       time.Duration // Time window for smoothing (e.g., 5 seconds)
	minAgreement int           // Minimum observations that must agree (e.g., 2 out of 3)
	storage      core.StorageDriver
}

func NewTemporalSmoother(storage core.StorageDriver) *TemporalSmoother {
	return &TemporalSmoother{
		window:       5 * time.Second,
		minAgreement: 2, // Require 2/3 agreement
		storage:      storage,
	}
}

// Smooth filters the new observation against recent history
func (t *TemporalSmoother) Smooth(newObs *core.Observation) (*core.Observation, error) {
	// Get recent observations for same device
	recent, err := t.storage.Query(newObs.DeviceID, 10) // Last 10 observations
	if err != nil {
		return newObs, nil // If query fails, return unsmoothed (graceful degradation)
	}

	// Filter to observations within time window
	cutoff := time.Now().Add(-t.window)
	var windowObs []core.Observation
	for _, obs := range recent {
		if obs.Timestamp.After(cutoff) {
			windowObs = append(windowObs, obs)
		}
	}

	// If no recent observations, return as-is (nothing to smooth against)
	if len(windowObs) == 0 {
		return newObs, nil
	}

	// Smooth LED signals
	smoothedLEDs := t.smoothLEDs(newObs, windowObs)

	// Smooth display signals
	smoothedDisplays := t.smoothDisplays(newObs, windowObs)

	// Combine smoothed signals
	var smoothedSignals []core.Signal
	smoothedSignals = append(smoothedSignals, smoothedLEDs...)
	smoothedSignals = append(smoothedSignals, smoothedDisplays...)

	return &core.Observation{
		ID:           newObs.ID,
		DeviceID:     newObs.DeviceID,
		FirmwareHash: newObs.FirmwareHash,
		Timestamp:    newObs.Timestamp,
		Signals:      smoothedSignals,
	}, nil
}

func (t *TemporalSmoother) smoothLEDs(newObs *core.Observation, history []core.Observation) []core.Signal {
	var smoothed []core.Signal

	// Extract LED signals from new observation
	newLEDs := extractLEDs(newObs.Signals)

	for _, newLED := range newLEDs {
		// Find this LED in recent history
		historicalStates := t.findLEDHistory(newLED.Name, history)

		// Check if new state agrees with historical trend
		if len(historicalStates) < t.minAgreement {
			// Not enough history → trust new observation
			smoothed = append(smoothed, newLED)
			continue
		}

		// Count agreement with historical states
		agreementCount := 0
		for _, histLED := range historicalStates {
			if t.ledsMatch(newLED, histLED) {
				agreementCount++
			}
		}

		// If majority agrees, keep new observation
		// If majority disagrees, it's likely noise → use historical state
		if agreementCount >= t.minAgreement {
			smoothed = append(smoothed, newLED)
		} else {
			// Use most recent historical state (likely more stable)
			if len(historicalStates) > 0 {
				smoothed = append(smoothed, historicalStates[0])
			}
		}
	}

	return smoothed
}

func (t *TemporalSmoother) smoothDisplays(newObs *core.Observation, history []core.Observation) []core.Signal {
	var smoothed []core.Signal

	// Extract display signals from new observation
	newDisplays := extractDisplays(newObs.Signals)

	for _, newDisplay := range newDisplays {
		// Find this display in recent history
		historicalTexts := t.findDisplayHistory(newDisplay.Name, history)

		// Check if new text agrees with historical trend
		if len(historicalTexts) < t.minAgreement {
			// Not enough history → trust new observation
			smoothed = append(smoothed, newDisplay)
			continue
		}

		// Count agreement (exact text match)
		agreementCount := 0
		for _, histText := range historicalTexts {
			if newDisplay.Text == histText {
				agreementCount++
			}
		}

		// If majority agrees, keep new observation
		// If majority disagrees, it's likely OCR glitch → use historical text
		if agreementCount >= t.minAgreement {
			smoothed = append(smoothed, newDisplay)
		} else {
			// Use most recent historical text
			if len(historicalTexts) > 0 {
				smoothed = append(smoothed, core.DisplaySignal{
					Name:       newDisplay.Name,
					Text:       historicalTexts[0],
					Confidence: newDisplay.Confidence,
				})
			}
		}
	}

	return smoothed
}

func (t *TemporalSmoother) findLEDHistory(name string, history []core.Observation) []core.LEDSignal {
	var leds []core.LEDSignal

	for _, obs := range history {
		for _, signal := range obs.Signals {
			if led, ok := signal.(core.LEDSignal); ok && led.Name == name {
				leds = append(leds, led)
			}
		}
	}

	return leds
}

func (t *TemporalSmoother) findDisplayHistory(name string, history []core.Observation) []string {
	var texts []string

	for _, obs := range history {
		for _, signal := range obs.Signals {
			if display, ok := signal.(core.DisplaySignal); ok && display.Name == name {
				texts = append(texts, display.Text)
			}
		}
	}

	return texts
}

func (t *TemporalSmoother) ledsMatch(a, b core.LEDSignal) bool {
	// LEDs match if on/off state and blink frequency are similar
	if a.On != b.On {
		return false
	}

	// Allow 10% tolerance on blink frequency
	if a.BlinkHz > 0 || b.BlinkHz > 0 {
		diff := abs(a.BlinkHz - b.BlinkHz)
		avg := (a.BlinkHz + b.BlinkHz) / 2.0
		if avg > 0 && diff/avg > 0.1 {
			return false
		}
	}

	return true
}

func abs(x float64) float64 {
	if x < 0 {
		return -x
	}
	return x
}

func extractLEDs(signals []core.Signal) []core.LEDSignal {
	var leds []core.LEDSignal
	for _, signal := range signals {
		if led, ok := signal.(core.LEDSignal); ok {
			leds = append(leds, led)
		}
	}
	return leds
}

func extractDisplays(signals []core.Signal) []core.DisplaySignal {
	var displays []core.DisplaySignal
	for _, signal := range signals {
		if display, ok := signal.(core.DisplaySignal); ok {
			displays = append(displays, display)
		}
	}
	return displays
}
```

**Integrate into Core.Observe:**

```go
// pkg/percepta/percepta.go

type Core struct {
	camera  core.CameraDriver
	vision  core.VisionDriver
	storage core.StorageDriver
	smoother *filter.TemporalSmoother // NEW
}

func NewCore(cameraPath string, storage core.StorageDriver) (*Core, error) {
	cameraDriver := camera.NewV4L2Camera(cameraPath)
	visionDriver, err := vision.NewClaudeVision()
	if err != nil {
		return nil, fmt.Errorf("vision init failed: %w", err)
	}

	return &Core{
		camera:   cameraDriver,
		vision:   visionDriver,
		storage:  storage,
		smoother: filter.NewTemporalSmoother(storage), // Initialize smoother
	}, nil
}

func (c *Core) Observe(deviceID string) (*core.Observation, error) {
	// ... existing capture and vision code ...

	obs := &core.Observation{
		ID:        core.GenerateID(),
		DeviceID:  deviceID,
		Timestamp: time.Now(),
		Signals:   signals,
	}

	// Apply temporal smoothing before returning
	smoothedObs, err := c.smoother.Smooth(obs)
	if err != nil {
		// Log but don't fail observation (graceful degradation)
		return obs, nil
	}

	return smoothedObs, nil
}
```

**Write tests:**
- LED glitch in single frame → filtered out by smoother
- Display OCR error in single frame → corrected by historical text
- Stable LED state over 3 frames → kept unchanged
- New device (no history) → observation returned as-is
- Storage query fails → graceful degradation (return unsmoothed)

AVOID: Over-aggressive smoothing. Only filter true anomalies (single-frame disagreements).
AVOID: Blocking on storage errors. Smoothing is nice-to-have, not critical.
  </action>
  <verify>go test ./internal/filter passes, transient noise filtered, stable signals preserved, graceful degradation works</verify>
  <done>TemporalSmoother works, filters single-frame anomalies, preserves stable signals, tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Lock JSON schema with versioning</name>
  <files>internal/core/types.go, internal/core/schema.go (new), internal/core/schema_test.go, internal/storage/sqlite_storage.go</files>
  <action>
Add schema versioning to Observation and enforce validation on serialization/deserialization.

**Add SchemaVersion to Observation:**

```go
// internal/core/types.go

// Observation is a snapshot of hardware state at a point in time
type Observation struct {
	SchemaVersion string    `json:"schema_version"` // NEW: Schema version for compatibility
	ID            string    `json:"id"`
	DeviceID      string    `json:"device_id"`
	FirmwareHash  string    `json:"firmware_hash,omitempty"`
	Timestamp     time.Time `json:"timestamp"`
	Signals       []Signal  `json:"signals"`
}

const CurrentSchemaVersion = "1.0.0" // Lock to v1.0.0
```

**Create schema validator:**

```go
// internal/core/schema.go

package core

import (
	"encoding/json"
	"fmt"
)

// SchemaValidator validates observation schema versions
type SchemaValidator struct {
	currentVersion string
	migrations     map[string]MigrationFunc
}

// MigrationFunc upgrades observation from old version to new version
type MigrationFunc func(data map[string]interface{}) (map[string]interface{}, error)

func NewSchemaValidator() *SchemaValidator {
	return &SchemaValidator{
		currentVersion: CurrentSchemaVersion,
		migrations: map[string]MigrationFunc{
			// Future migrations go here
			// "0.9.0->1.0.0": migrateV0ToV1,
		},
	}
}

// ValidateAndMigrate checks observation schema version and migrates if needed
func (v *SchemaValidator) ValidateAndMigrate(data []byte) (*Observation, error) {
	// Parse JSON to check schema version
	var raw map[string]interface{}
	if err := json.Unmarshal(data, &raw); err != nil {
		return nil, fmt.Errorf("invalid JSON: %w", err)
	}

	// Check schema version
	schemaVer, ok := raw["schema_version"].(string)
	if !ok || schemaVer == "" {
		// Missing schema_version → assume legacy format (pre-v1.0.0)
		// Inject current version and continue
		raw["schema_version"] = v.currentVersion
	} else if schemaVer != v.currentVersion {
		// Old schema → check if migration exists
		migrationKey := schemaVer + "->" + v.currentVersion
		if migration, exists := v.migrations[migrationKey]; exists {
			migrated, err := migration(raw)
			if err != nil {
				return nil, fmt.Errorf("migration failed: %w", err)
			}
			raw = migrated
		} else {
			return nil, fmt.Errorf("unsupported schema version: %s (current: %s, no migration available)", schemaVer, v.currentVersion)
		}
	}

	// Parse to Observation struct
	migrated, err := json.Marshal(raw)
	if err != nil {
		return nil, fmt.Errorf("re-serialization failed: %w", err)
	}

	var obs Observation
	if err := json.Unmarshal(migrated, &obs); err != nil {
		return nil, fmt.Errorf("observation parse failed: %w", err)
	}

	return &obs, nil
}

// EnsureSchemaVersion sets schema version on new observations
func EnsureSchemaVersion(obs *Observation) {
	if obs.SchemaVersion == "" {
		obs.SchemaVersion = CurrentSchemaVersion
	}
}
```

**Update Core.Observe to set schema version:**

```go
// pkg/percepta/percepta.go

func (c *Core) Observe(deviceID string) (*core.Observation, error) {
	// ... existing capture, vision, smoothing ...

	obs := &core.Observation{
		SchemaVersion: core.CurrentSchemaVersion, // NEW: Set schema version
		ID:            core.GenerateID(),
		DeviceID:      deviceID,
		Timestamp:     time.Now(),
		Signals:       signals,
	}

	// ... smoothing ...

	return smoothedObs, nil
}
```

**Update storage to validate on load:**

```go
// internal/storage/sqlite_storage.go

func (s *SQLiteStorage) Query(deviceID string, limit int) ([]core.Observation, error) {
	// ... existing SQLite query ...

	validator := core.NewSchemaValidator()

	var observations []core.Observation
	for rows.Next() {
		var data []byte
		if err := rows.Scan(&data); err != nil {
			return nil, err
		}

		// Validate and migrate if needed
		obs, err := validator.ValidateAndMigrate(data)
		if err != nil {
			// Log invalid observation but continue
			log.Printf("Warning: invalid observation schema: %v", err)
			continue
		}

		observations = append(observations, *obs)
	}

	return observations, nil
}
```

**Migration example (for future use):**

```go
// Example: migrate v0.9.0 → v1.0.0
func migrateV0ToV1(data map[string]interface{}) (map[string]interface{}, error) {
	// Example: rename field "leds" → "signals"
	if leds, ok := data["leds"]; ok {
		data["signals"] = leds
		delete(data, "leds")
	}

	data["schema_version"] = "1.0.0"
	return data, nil
}
```

**Write tests:**
- Observation with v1.0.0 schema → validates successfully
- Observation without schema_version (legacy) → injects v1.0.0
- Observation with future schema (v2.0.0) → migration fails gracefully
- Migration function registered → upgrades old observation
- Invalid JSON → returns error

**Schema lock commitment:**
- CurrentSchemaVersion = "1.0.0" locked
- Any changes to Observation struct MUST bump version and add migration
- Breaking changes require major version bump (2.0.0)

AVOID: Breaking existing observations in SQLite. Migrations must be backwards-compatible.
AVOID: Complex migration logic. Keep migrations simple and deterministic.
  </action>
  <verify>go test ./internal/core passes, schema version enforced, legacy observations migrated, validation works</verify>
  <done>SchemaValidator works, observations have locked v1.0.0 schema, migrations supported, tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./cmd/percepta` succeeds
- [ ] `percepta observe <device>` produces observations with schema_version="1.0.0"
- [ ] Temporal smoothing filters transient noise (single-frame glitches)
- [ ] Legacy observations (no schema_version) load successfully with migration
- [ ] All tests passing (filter, schema, storage)
- [ ] Schema lock documented in types.go
- [ ] Observations compatible with Phase 7 validation pipeline
</verification>

<success_criteria>

- TemporalSmoother working with 5-second window, 2/3 agreement threshold
- Single-frame anomalies filtered out (LED glitches, OCR errors)
- SchemaValidator enforces v1.0.0 schema on all observations
- Legacy observations migrate gracefully
- Schema version locked with migration path for future changes
- All tests passing
- Phase 7 ready: perception data stable and versioned
  </success_criteria>

<output>
After completion, create `.planning/phases/6.1-perception-enhancements/6.1-02-SUMMARY.md` following the summary.md template.

Include:
- Temporal smoothing algorithm (time window, agreement threshold, LED/display filtering)
- Schema versioning architecture (validator, migration functions, locked v1.0.0)
- Example smoothing scenarios (before/after filtering)
- Migration path for future schema changes
- Performance impact (negligible - smoothing uses cached queries)
- Integration notes for Phase 7 (stable schema enables safe validation pipeline)
- Phase 6.1 complete - perception enhancements done, ready for code generation validation
</output>
