---
phase: 03-diff-firmware-tracking
plan: 01
subsystem: storage
scope: small
estimated_tasks: 3
checkpoint_type: none
execution_mode: autonomous
requires:
  - phase: 01-01
    provides: [core-types, driver-interfaces, memory-storage]
  - phase: 02-02
    provides: [cli-assert-command, cli-observe-command]
  - phase: 2.5-01
    provides: [stable-signal-identity]
provides:
  - SQLite storage with schema
  - Firmware hash tracking via git
  - Storage interface swap (memory â†’ SQLite)
  - Observations persisted with firmware version
affects: [03-02]
tech-stack:
  added: [mattn/go-sqlite3, os/exec for git]
  patterns: [database-migrations, git-integration, interface-swap]
---

# Phase 3 Plan 1: Firmware Hash Tracking and Git Integration

## Objective

**Replace in-memory storage with SQLite and track firmware hash via git for each observation.**

This plan establishes persistent storage and firmware version tracking - the foundation for diff. Observations are saved to SQLite with their associated firmware commit hash, enabling version-based queries in Plan 03-02.

## Execution Context

**Files to read:**
- @internal/core/types.go - Observation struct (already has FirmwareHash field)
- @internal/storage/memory.go - Current in-memory implementation to replace
- @internal/core/interfaces.go - Check if StorageDriver interface exists
- @pkg/percepta/percepta.go - Core API that uses storage
- @cmd/percepta/observe.go - Observe command (needs firmware hash injection)
- @internal/config/config.go - Config structure (may need firmware_path field)

**Dependencies:**
- Phase 1: Core types and interfaces
- Phase 2.5: Stable signal identity (LED1, LED2, LED3)

**Tech stack additions:**
- `github.com/mattn/go-sqlite3` - SQLite driver for Go
- `os/exec` - Shell out to git for commit hash

## Context

**Current state:**
- Observations stored in memory (MemoryStorage)
- Observation.FirmwareHash field exists but unused
- No persistence between runs
- No firmware version tracking

**Target state:**
- SQLite storage at `~/.local/share/percepta/percepta.db`
- Schema: observations table with id, device_id, firmware_hash, timestamp, signals_json
- Firmware hash captured via `git rev-parse HEAD` in firmware directory
- Config specifies firmware path per device
- Observations queryable by device + firmware hash range

**Acceptance criteria:**
1. `percepta observe fpga` saves observation to SQLite with current git commit hash
2. Database file created automatically at `~/.local/share/percepta/percepta.db`
3. Firmware hash populated from git (empty string if not in git repo)
4. All existing observe/assert commands work with SQLite storage
5. Multiple observations accumulate in database

## Tasks

### Task 1: Implement SQLite storage with schema

**Objective:** Create SQLite storage implementation with observations table.

**Files to modify:**
- Create `internal/storage/sqlite.go`
- Create `internal/storage/schema.sql` (embedded via go:embed)

**Implementation:**
1. Define schema:
   ```sql
   CREATE TABLE IF NOT EXISTS observations (
       id TEXT PRIMARY KEY,
       device_id TEXT NOT NULL,
       firmware_hash TEXT,
       timestamp INTEGER NOT NULL,
       signals_json TEXT NOT NULL
   );
   CREATE INDEX IF NOT EXISTS idx_device_firmware ON observations(device_id, firmware_hash, timestamp);
   ```

2. Implement SQLiteStorage:
   - Constructor: NewSQLiteStorage(dbPath string) (*SQLiteStorage, error)
   - Open DB, run schema migration
   - Save(obs Observation) - serialize signals to JSON, insert row
   - Query(deviceID string, limit int) - query and deserialize
   - QueryByFirmware(deviceID, firmwareHash string) - for diff queries
   - Count() - for compatibility

3. Use `database/sql` + `github.com/mattn/go-sqlite3`
4. Default path: `~/.local/share/percepta/percepta.db`
5. Create parent directory if missing

**Success criteria:**
- SQLiteStorage implements storage interface
- Database auto-created on first use
- Observations serialize/deserialize correctly

### Task 2: Add git firmware hash extraction

**Objective:** Capture firmware commit hash via git and inject into observations.

**Files to modify:**
- Create `internal/firmware/git.go`
- Modify `internal/config/config.go` - add FirmwarePath per device
- Modify `pkg/percepta/percepta.go` - inject firmware hash into Observe()

**Implementation:**
1. Create firmware.GetGitHash(path string) (string, error):
   ```go
   cmd := exec.Command("git", "-C", path, "rev-parse", "HEAD")
   output, err := cmd.Output()
   if err != nil {
       return "", nil // Not a git repo, return empty
   }
   return strings.TrimSpace(string(output)), nil
   ```

2. Update Config struct:
   ```go
   type Device struct {
       CameraDevice string
       FirmwarePath string // Path to firmware git repo
   }
   ```

3. Update Core.Observe():
   - Load firmware path from config
   - Call firmware.GetGitHash(firmwarePath)
   - Set obs.FirmwareHash before storage.Save()

**Success criteria:**
- Firmware hash captured from git repo
- Empty string if not in git repo (no error)
- Config supports per-device firmware paths

### Task 3: Swap MemoryStorage for SQLiteStorage in main

**Objective:** Replace in-memory storage with SQLite in production code.

**Files to modify:**
- Modify `cmd/percepta/main.go` or `pkg/percepta/percepta.go` - swap storage initialization

**Implementation:**
1. Replace:
   ```go
   storage := storage.NewMemoryStorage()
   ```
   with:
   ```go
   dbPath := filepath.Join(os.Getenv("HOME"), ".local/share/percepta/percepta.db")
   storage, err := storage.NewSQLiteStorage(dbPath)
   if err != nil {
       return fmt.Errorf("failed to open database: %w", err)
   }
   ```

2. Keep MemoryStorage for tests (don't delete the file)

**Success criteria:**
- `percepta observe fpga` persists to SQLite
- Database file created at expected path
- Observations survive across CLI invocations
- No breaking changes to observe/assert commands

## Verification

**Manual testing:**
```bash
# Clean slate
rm -f ~/.local/share/percepta/percepta.db

# First observation
./percepta observe fpga
# Should see output + create database file

# Verify persistence
sqlite3 ~/.local/share/percepta/percepta.db "SELECT device_id, firmware_hash, timestamp FROM observations;"
# Should show 1 row with device=fpga, firmware_hash=(git hash or empty)

# Second observation
./percepta observe fpga
# Should add second row

# Verify count
sqlite3 ~/.local/share/percepta/percepta.db "SELECT COUNT(*) FROM observations;"
# Should show 2

# Verify firmware hash populated if in git repo
cd /path/to/firmware && git rev-parse HEAD
# Should match firmware_hash in database
```

**Automated testing:**
- Existing integration tests should pass (observe, assert commands)
- SQLite queries return correct observations

## Success Criteria

- [ ] SQLite storage implemented with schema
- [ ] Database auto-created at `~/.local/share/percepta/percepta.db`
- [ ] Firmware hash captured via git and stored
- [ ] Config supports per-device firmware paths
- [ ] MemoryStorage replaced with SQLiteStorage in production
- [ ] All observe/assert commands work with persistent storage
- [ ] Multiple observations accumulate in database
- [ ] Ready for Plan 03-02 (diff queries on firmware hash)

## Output

**Deliverables:**
1. `internal/storage/sqlite.go` - SQLite storage implementation
2. `internal/firmware/git.go` - Git hash extraction
3. Modified config with FirmwarePath field
4. Modified Core.Observe() to inject firmware hash
5. SQLite swap in main initialization
6. Database file persists observations across runs

**Verification artifacts:**
- Manual test results showing persistence
- Database schema inspection
- Firmware hash populated correctly

**Phase 3 Plan 1 enables:** Persistent observations with firmware version tracking, ready for diff queries in Plan 03-02.
