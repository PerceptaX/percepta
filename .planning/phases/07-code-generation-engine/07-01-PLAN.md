---
phase: 07-code-generation-engine
plan: 01
type: execute
---

<objective>
Build AI code generator that creates BARR-C compliant firmware using Claude API and knowledge graph patterns.

Purpose: Enable natural language firmware generation ("Blink LED at 1Hz") with professional code quality. Uses validated patterns from knowledge graph to provide context, ensuring generated code follows established working examples.

Output: Working code generator with Claude API integration, pattern-based prompt engineering, and CLI command for firmware generation.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-style-infrastructure/05-02-SUMMARY.md
@.planning/phases/06-knowledge-graphs/06-01-SUMMARY.md
@.planning/phases/06-knowledge-graphs/06-02-SUMMARY.md
@docs/Percepta_full.md

**From Phase 5:**
- StyleChecker for BARR-C validation
- Auto-fix engine for deterministic corrections
- Tree-sitter C parser

**From Phase 6:**
- PatternStore with validated patterns
- Semantic search API (SearchSimilarPatterns)
- Knowledge graph with observations and style metadata

**Tech stack available:**
- Go 1.21+
- Cobra CLI framework
- SQLite storage (modernc.org/sqlite)
- OpenAI API (for embeddings, already integrated)

**Key innovation from PRD:**
Generate code using:
1. Natural language spec → semantic search → similar validated patterns
2. Pattern context + BARR-C requirements → Claude API → generated code
3. StyleChecker validation → auto-fix → BARR-C compliant output

**Integration requirements:**
- Claude API (Anthropic API) for code generation
- Query knowledge graph for similar patterns (from Phase 6)
- Validate with StyleChecker (from Phase 5)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Claude API client for code generation</name>
  <files>internal/codegen/claude_client.go, internal/codegen/claude_client_test.go, go.mod</files>
  <action>
Create Claude API client using Anthropic SDK:

```go
type ClaudeClient struct {
    apiKey string
    model  string  // "claude-sonnet-4-5" or similar
}

func NewClaudeClient(apiKey string) *ClaudeClient {
    return &ClaudeClient{
        apiKey: apiKey,
        model:  "claude-sonnet-4-5",  // Latest model
    }
}

func (c *ClaudeClient) GenerateCode(
    spec string,           // "Blink LED at 1Hz"
    boardType string,      // "esp32"
    systemPrompt string,   // BARR-C requirements + patterns
    maxTokens int,
) (string, error) {
    // Call Anthropic API Messages endpoint
    // https://docs.anthropic.com/en/api/messages

    messages := []Message{
        {
            Role: "user",
            Content: fmt.Sprintf(`Generate firmware for %s board:

Specification: %s

Requirements:
- BARR-C compliant
- Use validated patterns provided in system prompt
- Non-blocking architecture (timers, not delays)
- Proper error handling
- Static allocation only

Output only the C source code, no explanations.`, boardType, spec),
        },
    }

    request := MessagesRequest{
        Model:        c.model,
        MaxTokens:    maxTokens,
        System:       systemPrompt,
        Messages:     messages,
        Temperature:  0.3,  // Lower for more deterministic code
    }

    response, err := c.callAPI(request)
    if err != nil {
        return "", fmt.Errorf("API call failed: %w", err)
    }

    // Extract code from response
    code := extractCode(response.Content[0].Text)
    return code, nil
}

func (c *ClaudeClient) callAPI(request MessagesRequest) (*MessagesResponse, error) {
    // HTTP POST to https://api.anthropic.com/v1/messages
    // Set headers: x-api-key, anthropic-version: 2023-06-01
    // Handle rate limiting, retries
}
```

Install Anthropic SDK or use HTTP client:
```bash
go get github.com/anthropics/anthropic-sdk-go
# OR implement HTTP client directly
```

API key from environment variable: `ANTHROPIC_API_KEY`

Write tests with mock HTTP responses:
- Generate code for simple spec → returns C code
- API error → returns error
- Empty response → returns error
- Rate limit → retries and succeeds

AVOID: Hardcoding API key in source. Always use env var or config file.
AVOID: Complex prompt engineering here (that's Task 2). This is just the API client.
  </action>
  <verify>go test ./internal/codegen/claude_client_test.go passes, can call API (with valid key) or mock</verify>
  <done>ClaudeClient works, can generate code via Claude API, handles errors, tests pass, API key from environment</done>
</task>

<task type="auto">
  <name>Task 2: Add pattern-based prompt engineering</name>
  <files>internal/codegen/prompt_builder.go, internal/codegen/prompt_builder_test.go</files>
  <action>
Create prompt builder that queries knowledge graph for context:

```go
type PromptBuilder struct {
    patternStore *knowledge.PatternStore
}

func (p *PromptBuilder) BuildSystemPrompt(
    spec string,
    boardType string,
) (string, error) {
    // 1. Search for similar validated patterns
    patterns, err := p.patternStore.SearchSimilarPatterns(spec, boardType, 3)
    if err != nil {
        return "", err
    }

    // 2. Build BARR-C requirements section
    barrRequirements := `
You are an expert embedded firmware engineer writing BARR-C compliant code.

BARR-C Style Requirements:
- Function names: Module_Function() format (e.g., LED_Init, Timer_Start)
- Variables: snake_case (e.g., led_state, timer_count)
- Constants: UPPER_SNAKE with meaningful names (e.g., LED_PIN, BLINK_PERIOD_MS)
- Types: Use stdint.h (uint8_t, uint16_t, uint32_t, not int/char)
- No magic numbers: Define all constants with #define
- Const correctness: const uint8_t* for read-only pointers
- Doxygen comments: /** ... */ for all functions
- Non-blocking: Use timers/interrupts, never blocking delays
- Error handling: Return error codes, check all returns
- Static allocation: No malloc/free
- Explicit casts: (uint16_t)value for type conversions

Code Structure:
1. Includes at top
2. Constants defined
3. Type definitions
4. Static variables
5. Function prototypes
6. Function implementations
7. Main function if required
`

    // 3. Add validated patterns as examples
    var patternExamples string
    if len(patterns) > 0 {
        patternExamples = "\nValidated Patterns (these work on real hardware):\n\n"
        for i, result := range patterns {
            patternExamples += fmt.Sprintf("Example %d (%.0f%% similar):\n", i+1, result.Similarity*100)
            patternExamples += fmt.Sprintf("Spec: %s\n", result.Pattern.Spec)
            patternExamples += fmt.Sprintf("Board: %s\n", result.Pattern.BoardType)
            patternExamples += fmt.Sprintf("Code:\n```c\n%s\n```\n\n", result.Pattern.Code)
        }
        patternExamples += "Use these patterns as reference. Adapt them to the current specification.\n"
    }

    // 4. Add board-specific notes if available
    var boardNotes string
    switch boardType {
    case "esp32":
        boardNotes = `
ESP32-specific:
- GPIO pins: Use gpio_set_level() from driver/gpio.h
- Timers: Use esp_timer_create() for non-blocking timing
- No Arduino-style digitalWrite()
`
    case "stm32":
        boardNotes = `
STM32-specific:
- GPIO: Use HAL_GPIO_WritePin()
- Timers: Use HAL timer functions
- Include stm32f4xx_hal.h
`
    }

    systemPrompt := barrRequirements + patternExamples + boardNotes
    return systemPrompt, nil
}
```

Write tests:
- Build prompt with patterns → includes pattern examples
- Build prompt without patterns (empty knowledge graph) → works with just BARR-C requirements
- Board-specific notes → includes correct GPIO/timer APIs

AVOID: Hardcoding patterns. Always query knowledge graph dynamically.
AVOID: Over-long prompts (>8k tokens). Limit to top 3 patterns.
  </action>
  <verify>go test ./internal/codegen passes, prompt includes BARR-C requirements and pattern examples</verify>
  <done>PromptBuilder queries knowledge graph, builds context-rich prompts, includes validated patterns, tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Add percepta generate CLI command</name>
  <files>cmd/percepta/generate.go, cmd/percepta/main.go (update)</files>
  <action>
Create CLI command following existing Cobra patterns:

```go
var generateCmd = &cobra.Command{
    Use:   "generate <spec> --board <type> [--output <file>]",
    Short: "Generate BARR-C compliant firmware from specification",
    Long:  `Uses AI and validated patterns to generate firmware code.

Example:
  percepta generate "Blink LED at 1Hz" --board esp32 --output led_blink.c`,
    Args:  cobra.MinimumNArgs(1),
    RunE:  runGenerate,
}

var (
    boardType   string
    outputFile  string
)

func init() {
    generateCmd.Flags().StringVarP(&boardType, "board", "b", "", "Board type (required)")
    generateCmd.Flags().StringVarP(&outputFile, "output", "o", "", "Output file (optional, prints to stdout if not set)")
    generateCmd.MarkFlagRequired("board")
}

func runGenerate(cmd *cobra.Command, args []string) error {
    spec := strings.Join(args, " ")

    // Check for API key
    apiKey := os.Getenv("ANTHROPIC_API_KEY")
    if apiKey == "" {
        return fmt.Errorf("ANTHROPIC_API_KEY not set\n\nGet your API key from: https://console.anthropic.com/\nSet it: export ANTHROPIC_API_KEY=your-key-here")
    }

    fmt.Printf("Generating firmware...\n")
    fmt.Printf("Spec: %s\n", spec)
    fmt.Printf("Board: %s\n\n", boardType)

    // 1. Build prompt with patterns
    patternStore, err := knowledge.NewPatternStore()
    if err != nil {
        return fmt.Errorf("failed to load patterns: %w", err)
    }

    promptBuilder := codegen.NewPromptBuilder(patternStore)
    systemPrompt, err := promptBuilder.BuildSystemPrompt(spec, boardType)
    if err != nil {
        return fmt.Errorf("failed to build prompt: %w", err)
    }

    // 2. Generate code
    client := codegen.NewClaudeClient(apiKey)
    code, err := client.GenerateCode(spec, boardType, systemPrompt, 4096)
    if err != nil {
        return fmt.Errorf("code generation failed: %w", err)
    }

    fmt.Printf("✓ Code generated (%d lines)\n\n", len(strings.Split(code, "\n")))

    // 3. Output
    if outputFile != "" {
        err = os.WriteFile(outputFile, []byte(code), 0644)
        if err != nil {
            return fmt.Errorf("failed to write file: %w", err)
        }
        fmt.Printf("Saved to: %s\n", outputFile)
    } else {
        fmt.Println(code)
    }

    // 4. Note about validation (Phase 07-02)
    fmt.Println("\n---")
    fmt.Printf("Next: Validate with `percepta style-check %s`\n", outputFile)

    return nil
}
```

Register in main.go:
```go
rootCmd.AddCommand(generateCmd)
```

Output format:
- Clear progress messages
- Show spec and board
- Print or save code
- Suggest next steps (style validation)

AVOID: Complex validation in this task (that's Plan 07-02). This just generates code.
AVOID: Storing patterns here (that's Plan 07-02). This just generates and outputs.
  </action>
  <verify>percepta generate "Blink LED" --board esp32 generates code, percepta generate --help shows usage</verify>
  <done>CLI command works, generates code from spec, outputs to file or stdout, help text clear, integrates with PatternStore</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./cmd/percepta` succeeds
- [ ] `percepta generate --help` shows command
- [ ] Can generate code: `percepta generate "Blink LED" --board esp32`
- [ ] Generated code includes BARR-C patterns
- [ ] If patterns exist in knowledge graph, they appear in prompt
- [ ] Works with valid ANTHROPIC_API_KEY
- [ ] Clear error if API key missing
- [ ] Can save to file with --output flag
</verification>

<success_criteria>

- Claude API client working (calls Anthropic Messages API)
- PromptBuilder queries knowledge graph for similar patterns
- Generates context-rich prompts with BARR-C requirements
- CLI command `percepta generate` functional
- Generated code follows patterns from knowledge graph
- All tests passing
- Ready for Phase 07-02 (validation pipeline)
  </success_criteria>

<output>
After completion, create `.planning/phases/07-code-generation-engine/07-01-SUMMARY.md` following the summary.md template.

Include:
- Claude API integration details (SDK vs HTTP client)
- Pattern-based prompt engineering approach
- Example prompt with retrieved patterns
- CLI usage examples with generated code samples
- Integration with knowledge graph demonstrated
- Note: This provides generation capability, Plan 07-02 adds validation pipeline
</output>
