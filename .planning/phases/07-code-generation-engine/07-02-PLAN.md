---
phase: 07-code-generation-engine
plan: 02
type: execute
---

<objective>
Add validation pipeline that style-checks generated code and stores successful patterns in knowledge graph.

Purpose: Complete the code generation loop by validating generated code against BARR-C standards and storing working patterns for future reference. This builds the knowledge base over time, making future generations better.

Output: Working validation pipeline that checks style compliance and auto-stores validated patterns, completing Phase 7 code generation engine.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-code-generation-engine/07-01-SUMMARY.md
@docs/Percepta_full.md

**From 07-01:**
- ClaudeClient for code generation
- PromptBuilder with pattern retrieval
- CLI command `percepta generate`

**From Phase 5:**
- StyleChecker.CheckSource() for validation
- StyleFixer for auto-fix
- BARR-C compliance checking

**From Phase 6:**
- PatternStore.StoreValidatedPattern() for storage
- Knowledge graph with patterns and observations

**Validation pipeline goal:**
1. Generate code (from 07-01)
2. Validate with StyleChecker → auto-fix if needed
3. Store validated pattern in knowledge graph (if clean)
4. Enable iterative improvement (future: feedback loop)

**MVP scope for Phase 7:**
- Style validation only (hardware validation deferred to Phase 8)
- Store patterns that pass style check
- Link to mock observation for now (real hardware validation later)

**Future enhancement (Phase 8):**
- Flash to hardware
- Observe with vision
- Validate observed vs expected
- Iteration loop with feedback
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create generation pipeline with validation</name>
  <files>internal/codegen/pipeline.go, internal/codegen/pipeline_test.go</files>
  <action>
Create pipeline that combines generation + validation:

```go
type GenerationPipeline struct {
    claudeClient  *ClaudeClient
    promptBuilder *PromptBuilder
    styleChecker  *style.StyleChecker
    styleFixer    *style.StyleFixer
    patternStore  *knowledge.PatternStore
}

type GenerationResult struct {
    Code            string
    StyleCompliant  bool
    Violations      []style.Violation
    AutoFixed       bool
    PatternStored   bool
    IterationsUsed  int
}

func (p *GenerationPipeline) Generate(
    spec string,
    boardType string,
    deviceID string,  // For pattern storage linkage
) (*GenerationResult, error) {
    result := &GenerationResult{}

    // 1. Build context-rich prompt
    systemPrompt, err := p.promptBuilder.BuildSystemPrompt(spec, boardType)
    if err != nil {
        return nil, fmt.Errorf("prompt building failed: %w", err)
    }

    // 2. Generate code
    code, err := p.claudeClient.GenerateCode(spec, boardType, systemPrompt, 4096)
    if err != nil {
        return nil, fmt.Errorf("code generation failed: %w", err)
    }
    result.Code = code
    result.IterationsUsed = 1

    // 3. Style validation
    violations, err := p.styleChecker.CheckSource([]byte(code), "generated.c")
    if err != nil {
        return nil, fmt.Errorf("style check failed: %w", err)
    }
    result.Violations = violations

    // 4. Auto-fix if violations exist
    if len(violations) > 0 {
        fixed := p.styleFixer.ApplyFixes(violations, []byte(code))
        code = string(fixed)
        result.Code = code
        result.AutoFixed = true

        // Re-check after fixes
        violations, _ = p.styleChecker.CheckSource([]byte(code), "generated.c")
        result.Violations = violations
    }

    // 5. Check if fully compliant
    result.StyleCompliant = len(violations) == 0

    // 6. Store pattern if style compliant (MVP: no hardware validation yet)
    if result.StyleCompliant {
        // Create mock observation for MVP (Phase 8 will add real hardware observation)
        err = p.patternStore.StoreValidatedPattern(spec, code, deviceID, "generated-v1")
        if err != nil {
            // Log but don't fail - storage is nice-to-have
            log.Printf("Warning: failed to store pattern: %v", err)
        } else {
            result.PatternStored = true
        }
    }

    return result, nil
}
```

MVP approach:
- Style validation only (no hardware flashing)
- Store patterns that pass style check
- Phase 8 will add: flash → observe → validate loop

Write tests:
- Generate code → style violations found → auto-fixes → stores pattern
- Generate clean code → stores pattern immediately
- Generate code with unfixable violations → returns violations, doesn't store
- Storage failure → doesn't fail generation (graceful degradation)

AVOID: Complex iteration loops with hardware feedback (Phase 8). This is MVP validation.
AVOID: Requiring hardware observation for pattern storage (Phase 8). Use mock for now.
  </action>
  <verify>go test ./internal/codegen passes, pipeline generates and validates code, stores patterns when clean</verify>
  <done>GenerationPipeline works, integrates generation + validation + storage, handles auto-fix, tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Integrate validation pipeline into CLI</name>
  <files>cmd/percepta/generate.go (update), internal/codegen/report.go</files>
  <action>
Update CLI to use validation pipeline and show detailed results:

```go
// In cmd/percepta/generate.go, update runGenerate:

func runGenerate(cmd *cobra.Command, args []string) error {
    spec := strings.Join(args, " ")

    // Check for API key
    apiKey := os.Getenv("ANTHROPIC_API_KEY")
    if apiKey == "" {
        return fmt.Errorf("ANTHROPIC_API_KEY not set")
    }

    // Get device ID from config (for pattern linkage)
    cfg := config.Load()
    deviceID := cfg.CurrentDevice
    if deviceID == "" {
        deviceID = "unknown-device"  // Fallback for testing
    }

    fmt.Printf("Generating firmware...\n")
    fmt.Printf("Spec: %s\n", spec)
    fmt.Printf("Board: %s\n", boardType)
    fmt.Printf("Device: %s\n\n", deviceID)

    // Initialize pipeline
    patternStore, _ := knowledge.NewPatternStore()
    styleChecker := style.NewStyleChecker()
    styleFixer := style.NewStyleFixer()
    claudeClient := codegen.NewClaudeClient(apiKey)
    promptBuilder := codegen.NewPromptBuilder(patternStore)

    pipeline := codegen.NewGenerationPipeline(
        claudeClient,
        promptBuilder,
        styleChecker,
        styleFixer,
        patternStore,
    )

    // Generate with validation
    spinner.Start("Generating code...")
    result, err := pipeline.Generate(spec, boardType, deviceID)
    spinner.Stop()

    if err != nil {
        return fmt.Errorf("generation failed: %w", err)
    }

    // Print detailed report
    codegen.PrintGenerationReport(result)

    // Output code
    if outputFile != "" {
        err = os.WriteFile(outputFile, []byte(result.Code), 0644)
        if err != nil {
            return fmt.Errorf("failed to write file: %w", err)
        }
        fmt.Printf("\nSaved to: %s\n", outputFile)
    } else {
        fmt.Println("\n" + result.Code)
    }

    return nil
}
```

Create report formatter:

```go
// internal/codegen/report.go

func PrintGenerationReport(result *GenerationResult) {
    fmt.Println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
    fmt.Println("GENERATION REPORT")
    fmt.Println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")

    // Style compliance
    if result.StyleCompliant {
        fmt.Println("✓ Style: BARR-C compliant")
    } else {
        fmt.Printf("✗ Style: %d violation(s) remaining\n", len(result.Violations))
        for _, v := range result.Violations {
            fmt.Printf("  Line %d: %s [%s]\n", v.Line, v.Message, v.Rule.Name)
        }
    }

    // Auto-fix status
    if result.AutoFixed {
        fmt.Println("✓ Auto-fix: Applied deterministic corrections")
    }

    // Pattern storage
    if result.PatternStored {
        fmt.Println("✓ Pattern: Stored in knowledge graph")
        fmt.Println("  (Will improve future generations)")
    }

    // Code stats
    lines := len(strings.Split(result.Code, "\n"))
    fmt.Printf("\nCode: %d lines generated in %d iteration(s)\n", lines, result.IterationsUsed)

    fmt.Println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
}
```

CLI behavior:
- Generate code with pipeline
- Show detailed validation report
- Auto-fix violations where possible
- Store pattern if clean
- Clear visual feedback for each step

AVOID: Hiding validation details. Show user what's happening (transparency builds trust).
AVOID: Failing if pattern storage fails. Generation success ≠ storage success.
  </action>
  <verify>percepta generate "Blink LED" --board esp32 --output led.c shows validation report, stores pattern if clean</verify>
  <done>CLI uses pipeline, shows detailed report, auto-fixes violations, stores patterns, clear visual feedback</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `go build ./cmd/percepta` succeeds
- [ ] `percepta generate "Blink LED" --board esp32 --output led.c` works
- [ ] Generated code is validated with StyleChecker
- [ ] Auto-fix applied if violations exist
- [ ] Clean code stored in knowledge graph
- [ ] Report shows: style status, auto-fix status, pattern storage status
- [ ] Can query stored patterns: `percepta knowledge list --board esp32`
- [ ] Stored patterns appear in future generation prompts (context improvement)
</verification>

<success_criteria>

- Generation pipeline working (generate + validate + store)
- StyleChecker integration complete
- Auto-fix applied automatically
- Patterns stored when style compliant
- CLI shows detailed generation report
- Knowledge graph grows with successful generations
- All tests passing
- Phase 7 complete: AI code generation operational
  </success_criteria>

<output>
After completion, create `.planning/phases/07-code-generation-engine/07-02-SUMMARY.md` following the summary.md template.

Include:
- Generation pipeline architecture
- Validation flow (generate → check → fix → store)
- Example generation report with statistics
- Pattern storage examples (before/after knowledge graph growth)
- Integration readiness notes
- Note: Phase 7 complete - v2.0 code generation milestone achieved
- Future enhancements for Phase 8: hardware validation loop (flash + observe + iterate)
</output>
