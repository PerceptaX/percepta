---
phase: 06-knowledge-graphs
plan: 01
type: execute
---

<objective>
Build knowledge graph storage foundation to store validated firmware patterns with behavioral and style metadata.

Purpose: Enable pattern-based code generation by storing relationships between code, hardware behaviors, and style compliance. This is Percepta's moat - validated patterns that actually work on real hardware, not just theoretical code from GitHub.

Output: Working graph database with schema, pattern storage API that links code to observations and style compliance.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-style-infrastructure/05-01-SUMMARY.md
@.planning/phases/05-style-infrastructure/05-02-SUMMARY.md
@docs/Percepta_full.md

**From Phase 5:**
- StyleChecker can validate BARR-C compliance
- Auto-fix engine available for pattern cleanup
- Tree-sitter parser for C code analysis

**Tech stack available:**
- Go 1.21+
- SQLite (modernc.org/sqlite) for perception data
- Cobra for CLI commands
- Tree-sitter for C parsing

**Key decision from PRD:**
- Use graph database for relationship storage (Neo4j mentioned, but consider Go-native alternatives like dgraph for zero CGO)
- Store validated patterns only (observation + assertion passed + style compliant)

**Integration points:**
- Link to existing Observation records (from pkg/percepta/storage)
- Link to StyleChecker results (from internal/style)
- Provide query API for Phase 7 (code generation)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up graph database with schema</name>
  <files>internal/knowledge/graph.go, internal/knowledge/schema.go, go.mod</files>
  <action>
Evaluate graph database options:
1. **dgraph** - Pure Go, no CGO, embeddable (RECOMMENDED - matches modernc.org/sqlite decision from Phase 3)
2. **Neo4j** - Mentioned in PRD but requires external service
3. **In-memory graph** - Simplest MVP, can migrate later

For quick depth + pure Go architecture: Use dgraph client or implement simple in-memory graph with persistence to SQLite.

Create schema for knowledge graph:

```go
// Node types
type PatternNode struct {
    ID              string
    Code            string  // C source code
    Spec            string  // Natural language spec
    BoardType       string  // "esp32", "stm32", etc.
    StyleCompliant  bool
    CreatedAt       time.Time
}

type ObservationNode struct {
    ID          string
    DeviceID    string
    Firmware    string
    Signals     []Signal  // LED states, displays, etc.
    Timestamp   time.Time
}

type StyleResultNode struct {
    ID          string
    Violations  []Violation
    AutoFixed   bool
    Compliant   bool
}

// Relationships
type Relationship string
const (
    IMPLEMENTED_BY  Relationship = "IMPLEMENTED_BY"  // Spec -> Code
    RUNS_ON         Relationship = "RUNS_ON"         // Code -> Board
    PRODUCES        Relationship = "PRODUCES"        // Code -> Observation
    VALIDATED_BY    Relationship = "VALIDATED_BY"    // Code -> StyleResult
    SIMILAR_TO      Relationship = "SIMILAR_TO"      // Code -> Code (for later semantic search)
)
```

Store graphs in `.percepta/knowledge/` directory (similar to SQLite storage pattern).

AVOID: External dependencies requiring network services. Keep it embeddable like the rest of Percepta.

For MVP: In-memory graph with SQLite persistence is acceptable. Can upgrade to dgraph later if needed.
  </action>
  <verify>go build ./internal/knowledge succeeds, can create graph and add nodes</verify>
  <done>Graph database initialized, schema defined, can store and retrieve nodes with relationships, persists to disk</done>
</task>

<task type="auto">
  <name>Task 2: Create PatternStore API for validated code</name>
  <files>internal/knowledge/pattern_store.go, internal/knowledge/pattern_store_test.go</files>
  <action>
Create PatternStore that integrates perception + style checking:

```go
type PatternStore struct {
    graph      *Graph
    styleCheck *style.StyleChecker
    storage    percepta.StorageDriver  // For observations
}

func (p *PatternStore) StoreValidatedPattern(
    spec string,
    code string,
    deviceID string,
    firmware string,
) error {
    // 1. Validate style compliance
    violations, err := p.styleCheck.CheckSource([]byte(code), "pattern.c")
    if len(violations) > 0 {
        return fmt.Errorf("code not BARR-C compliant: %d violations", len(violations))
    }

    // 2. Get observation for this firmware
    obs, err := p.storage.GetObservation(deviceID, firmware)
    if err != nil {
        return fmt.Errorf("no observation found: %w", err)
    }

    // 3. Create pattern node
    pattern := PatternNode{
        ID:             generateID(),
        Code:           code,
        Spec:           spec,
        BoardType:      getBoardType(deviceID),
        StyleCompliant: true,
        CreatedAt:      time.Now(),
    }

    // 4. Store relationships
    p.graph.AddNode(pattern)
    p.graph.AddRelationship(spec, pattern.ID, IMPLEMENTED_BY)
    p.graph.AddRelationship(pattern.ID, deviceID, RUNS_ON)
    p.graph.AddRelationship(pattern.ID, obs.ID, PRODUCES)

    return nil
}

func (p *PatternStore) QueryPatternsByBoard(boardType string) ([]PatternNode, error) {
    // Query patterns that run on this board
    return p.graph.Query("MATCH (p:Pattern)-[:RUNS_ON]->(b:Board {type: $board})", boardType)
}

func (p *PatternStore) QueryPatternsBySpec(spec string) ([]PatternNode, error) {
    // Find patterns implementing similar specs
    return p.graph.Query("MATCH (s:Spec {text: $spec})-[:IMPLEMENTED_BY]->(p:Pattern)", spec)
}
```

Integration with existing storage:
- Read from pkg/percepta/storage (SQLite) for observations
- Use internal/style for validation
- Store graph in new knowledge layer

Write comprehensive tests:
- Store pattern with valid code + observation → succeeds
- Store pattern with style violations → fails
- Query by board type → returns relevant patterns
- Query by spec → returns implementations

AVOID: Storing non-validated patterns. Only patterns that passed (observe + assert + style check) go into knowledge graph.
  </action>
  <verify>go test ./internal/knowledge passes, can store pattern and query by board/spec</verify>
  <done>PatternStore API works, integrates with style checker and storage, only stores validated patterns, tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./internal/knowledge` succeeds
- [ ] `go test ./internal/knowledge` passes all tests
- [ ] Can store a validated pattern with relationships
- [ ] Can query patterns by board type and spec
- [ ] Graph persists to disk and reloads correctly
- [ ] Integration with StyleChecker works (rejects non-compliant code)
- [ ] Integration with percepta.StorageDriver works (links to observations)
</verification>

<success_criteria>

- Graph database setup and working (in-memory + SQLite persistence acceptable for MVP)
- PatternStore API implemented
- Can store validated patterns with full relationship graph
- Can query patterns by board type and spec
- Integration with Phase 5 style checking works
- Integration with Phase 1-4 observation storage works
- All tests passing
- Ready for Phase 06-02 (semantic search)
  </success_criteria>

<output>
After completion, create `.planning/phases/06-knowledge-graphs/06-01-SUMMARY.md` following the summary.md template.

Include:
- Graph database choice and rationale (pure Go vs external service)
- Schema design for patterns, observations, and relationships
- PatternStore API usage examples
- Integration points with existing systems
- Query capabilities demonstrated
- Example: store pattern for "blink LED" on ESP32, query similar patterns
- Note: This provides foundation for Phase 06-02 (semantic search) and Phase 07 (code generation)
</output>
