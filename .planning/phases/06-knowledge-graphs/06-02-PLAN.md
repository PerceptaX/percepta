---
phase: 06-knowledge-graphs
plan: 02
type: execute
---

<objective>
Add semantic search capability and CLI commands to query knowledge graph by code similarity.

Purpose: Enable code generation (Phase 7) to find similar validated patterns using semantic search. Instead of exact-match queries, find patterns that solve similar problems even with different implementations.

Output: Working vector store with code embeddings, semantic search API, and CLI commands to manage patterns.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-knowledge-graphs/06-01-SUMMARY.md
@docs/Percepta_full.md

**From 06-01:**
- Graph database with pattern storage
- PatternStore API for validated code
- Schema for patterns, observations, relationships
- Query by board type and spec (exact match)

**Tech stack available:**
- Go 1.21+
- Graph database (from 06-01)
- Cobra for CLI commands
- StyleChecker for validation

**Semantic search requirements:**
- Find similar code patterns by meaning, not exact text
- Use embeddings to represent code semantically
- Query: "blink LED" → should find timer-based, delay-based, interrupt-based implementations

**Key decision from PRD:**
- Qdrant mentioned for vector store (but requires external service)
- Alternative: Use pure Go solution like github.com/pgvector/pgvector-go or in-memory with persistence
- Need embedding model (OpenAI ada-002, or local model like all-MiniLM-L6-v2)

**For MVP quick depth:**
- Simple cosine similarity in-memory is acceptable
- Can upgrade to Qdrant/Milvus later if performance needed
- Use OpenAI embeddings API (already using Claude API, same account)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up vector store for code embeddings</name>
  <files>internal/knowledge/vector_store.go, internal/knowledge/embeddings.go, go.mod</files>
  <action>
Create vector store for code similarity search.

For quick depth MVP, use in-memory vector store with SQLite persistence:

```go
type VectorStore struct {
    embeddings map[string][]float32  // patternID -> embedding vector
    db         *sql.DB                 // SQLite for persistence
}

type EmbeddingProvider interface {
    Embed(code string) ([]float32, error)
}

type OpenAIEmbeddings struct {
    apiKey string
    model  string  // "text-embedding-ada-002"
}

func (o *OpenAIEmbeddings) Embed(code string) ([]float32, error) {
    // Call OpenAI API to get embeddings
    // Use same API client pattern as Claude
    // Cache embeddings to avoid redundant API calls
}
```

Store embeddings alongside graph in `.percepta/knowledge/embeddings.db`.

Cosine similarity for search:

```go
func (v *VectorStore) FindSimilar(queryCode string, topK int) ([]PatternMatch, error) {
    queryVec, err := v.embedder.Embed(queryCode)
    if err != nil {
        return nil, err
    }

    // Compute cosine similarity with all stored embeddings
    var matches []PatternMatch
    for patternID, embedding := range v.embeddings {
        similarity := cosineSimilarity(queryVec, embedding)
        matches = append(matches, PatternMatch{
            PatternID:  patternID,
            Similarity: similarity,
        })
    }

    // Sort by similarity, return top K
    sort.Slice(matches, func(i, j int) bool {
        return matches[i].Similarity > matches[j].Similarity
    })

    if len(matches) > topK {
        matches = matches[:topK]
    }

    return matches, nil
}
```

AVOID: Complex vector DB setup (Qdrant, Milvus) for MVP. In-memory + SQLite persistence follows established pattern (same as Phase 3 decision for modernc.org/sqlite).

For production scaling (Phase 8): Can migrate to proper vector DB if dataset grows >10k patterns.
  </action>
  <verify>go test ./internal/knowledge/vector_store_test.go passes, can store and search embeddings</verify>
  <done>Vector store works, can store embeddings, cosine similarity search returns relevant patterns, persists to SQLite</done>
</task>

<task type="auto">
  <name>Task 2: Add semantic search API for pattern retrieval</name>
  <files>internal/knowledge/semantic_search.go, internal/knowledge/semantic_search_test.go</files>
  <action>
Extend PatternStore with semantic search:

```go
func (p *PatternStore) SearchSimilarPatterns(
    query string,           // Natural language or code snippet
    boardType string,       // Filter by board (optional, "" for all)
    topK int,              // Number of results
) ([]PatternResult, error) {
    // 1. Find similar patterns by embedding
    matches, err := p.vectorStore.FindSimilar(query, topK*2)  // Get extra for filtering

    // 2. Filter by board type if specified
    var results []PatternResult
    for _, match := range matches {
        pattern, err := p.graph.GetNode(match.PatternID)
        if err != nil {
            continue
        }

        // Skip if board type doesn't match
        if boardType != "" && pattern.BoardType != boardType {
            continue
        }

        // Skip if not style compliant (safety check)
        if !pattern.StyleCompliant {
            continue
        }

        results = append(results, PatternResult{
            Pattern:    pattern,
            Similarity: match.Similarity,
            Confidence: calculateConfidence(match.Similarity, pattern),
        })

        if len(results) >= topK {
            break
        }
    }

    return results, nil
}

func calculateConfidence(similarity float32, pattern PatternNode) float32 {
    // High similarity + validated + style compliant = high confidence
    base := similarity

    // Boost if pattern has multiple successful observations
    // Penalize if pattern is very new (less validation)

    return base
}
```

Integration example for code generation (Phase 7):

```go
// When user asks: "Blink LED on ESP32"
results, err := store.SearchSimilarPatterns(
    "Blink LED using timer",
    "esp32",
    5,
)

// Returns validated patterns ranked by relevance:
// 1. Timer-based LED blink (0.92 similarity)
// 2. Non-blocking LED toggle (0.87 similarity)
// 3. Interrupt-driven LED (0.81 similarity)
```

Write tests:
- Search with exact spec match → returns pattern
- Search with similar spec → returns related patterns
- Search with board filter → only returns matching boards
- Similarity ranking → most relevant first

AVOID: Returning non-validated patterns. All search results must have StyleCompliant=true and linked observations.
  </action>
  <verify>go test ./internal/knowledge passes, semantic search returns relevant patterns ranked by similarity</verify>
  <done>Semantic search API works, returns validated patterns ranked by relevance, board filtering works, confidence scores calculated</done>
</task>

<task type="auto">
  <name>Task 3: Add CLI commands for pattern management</name>
  <files>cmd/percepta/knowledge.go, cmd/percepta/main.go (update)</files>
  <action>
Create CLI commands following existing Cobra patterns from device.go and style.go:

```go
var knowledgeCmd = &cobra.Command{
    Use:   "knowledge",
    Short: "Manage validated pattern knowledge graph",
    Long:  "Store and query validated firmware patterns with behavioral and style metadata.",
}

var storePatternCmd = &cobra.Command{
    Use:   "store <spec> <file.c> --device <device-id> --firmware <tag>",
    Short: "Store validated pattern in knowledge graph",
    Long:  "Validates code against BARR-C, links to observation, stores in graph.",
    Args:  cobra.ExactArgs(2),
    RunE:  runStorePattern,
}

var searchPatternsCmd = &cobra.Command{
    Use:   "search <query> [--board <type>] [--limit <n>]",
    Short: "Search for similar validated patterns",
    Long:  "Semantic search for patterns solving similar problems.",
    Args:  cobra.ExactArgs(1),
    RunE:  runSearchPatterns,
}

var listPatternsCmd = &cobra.Command{
    Use:   "list [--board <type>]",
    Short: "List all validated patterns",
    Args:  cobra.NoArgs,
    RunE:  runListPatterns,
}

func runStorePattern(cmd *cobra.Command, args []string) error {
    spec := args[0]
    codeFile := args[1]
    deviceID, _ := cmd.Flags().GetString("device")
    firmware, _ := cmd.Flags().GetString("firmware")

    code, err := os.ReadFile(codeFile)
    if err != nil {
        return fmt.Errorf("failed to read code: %w", err)
    }

    // Initialize knowledge store (reads from ~/.percepta/)
    store, err := knowledge.NewPatternStore()
    if err != nil {
        return err
    }

    // Store pattern (validates style + links to observation)
    err = store.StoreValidatedPattern(spec, string(code), deviceID, firmware)
    if err != nil {
        return fmt.Errorf("failed to store pattern: %w", err)
    }

    fmt.Printf("✓ Pattern stored: %s\n", spec)
    fmt.Printf("  Device: %s\n", deviceID)
    fmt.Printf("  Firmware: %s\n", firmware)
    return nil
}

func runSearchPatterns(cmd *cobra.Command, args []string) error {
    query := args[0]
    boardType, _ := cmd.Flags().GetString("board")
    limit, _ := cmd.Flags().GetInt("limit")

    store, _ := knowledge.NewPatternStore()
    results, err := store.SearchSimilarPatterns(query, boardType, limit)
    if err != nil {
        return err
    }

    fmt.Printf("Found %d similar patterns:\n\n", len(results))
    for i, result := range results {
        fmt.Printf("%d. %s (%.0f%% match)\n", i+1, result.Pattern.Spec, result.Similarity*100)
        fmt.Printf("   Board: %s\n", result.Pattern.BoardType)
        fmt.Printf("   Style: BARR-C compliant\n")
        fmt.Printf("   Code: %d lines\n", len(strings.Split(result.Pattern.Code, "\n")))
        if i < len(results)-1 {
            fmt.Println()
        }
    }
    return nil
}
```

Register commands:
```go
func init() {
    rootCmd.AddCommand(knowledgeCmd)
    knowledgeCmd.AddCommand(storePatternCmd)
    knowledgeCmd.AddCommand(searchPatternsCmd)
    knowledgeCmd.AddCommand(listPatternsCmd)

    storePatternCmd.Flags().StringP("device", "d", "", "Device ID (required)")
    storePatternCmd.Flags().StringP("firmware", "f", "", "Firmware tag (required)")
    storePatternCmd.MarkFlagRequired("device")
    storePatternCmd.MarkFlagRequired("firmware")

    searchPatternsCmd.Flags().StringP("board", "b", "", "Filter by board type")
    searchPatternsCmd.Flags().IntP("limit", "l", 5, "Number of results")
}
```

Output format follows existing CLI patterns (clear, actionable, easy to parse).

AVOID: Interactive prompts. Keep it scriptable for CI integration.
  </action>
  <verify>percepta knowledge --help shows commands, can store pattern and search</verify>
  <done>CLI commands work, can store validated patterns, search returns ranked results, list shows all patterns, help text clear</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `go build ./cmd/percepta` succeeds
- [ ] `percepta knowledge --help` shows all commands
- [ ] Can store a pattern: `percepta knowledge store "blink LED" led.c --device esp32-dev --firmware v1.0`
- [ ] Can search patterns: `percepta knowledge search "toggle LED" --board esp32 --limit 3`
- [ ] Search returns relevant patterns ranked by similarity
- [ ] Board filtering works correctly
- [ ] Only returns validated (style compliant) patterns
- [ ] Vector embeddings persist across restarts
</verification>

<success_criteria>

- Vector store with code embeddings working
- Semantic search API returns relevant patterns
- Cosine similarity ranking functional
- CLI commands for pattern management complete
- Can store validated patterns via CLI
- Can search patterns semantically
- Integration with Phase 06-01 graph storage works
- All tests passing
- Ready for Phase 7 (code generation can query knowledge graph)
  </success_criteria>

<output>
After completion, create `.planning/phases/06-knowledge-graphs/06-02-SUMMARY.md` following the summary.md template.

Include:
- Vector store implementation (in-memory + SQLite persistence)
- Embedding provider choice (OpenAI vs local)
- Semantic search algorithm (cosine similarity)
- CLI usage examples
- Example: search for "blink LED" returns timer-based, delay-based, interrupt-based patterns
- Performance notes (acceptable for <10k patterns, can scale with Qdrant later)
- Integration readiness for Phase 7 code generation
- Note: Phase 6 complete - knowledge graph ready to guide AI code generation
</output>
